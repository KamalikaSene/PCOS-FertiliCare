"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oauth4webapi";
exports.ids = ["vendor-chunks/oauth4webapi"];
exports.modules = {

/***/ "(action-browser)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isOAuth2Error: () => (/* binding */ isOAuth2Error),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   parseWwwAuthenticateChallenges: () => (/* binding */ parseWwwAuthenticateChallenges),\n/* harmony export */   processAuthorizationCodeOAuth2Response: () => (/* binding */ processAuthorizationCodeOAuth2Response),\n/* harmony export */   processAuthorizationCodeOpenIDResponse: () => (/* binding */ processAuthorizationCodeOpenIDResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v2.4.0\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    } catch (cause) {\n        throw new OPE(\"The input to be decoded is not correctly encoded.\", {\n            cause\n        });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize){\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if (v = this._cache.get(key)) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        } else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message){\n        super(message ?? \"operation not supported\");\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === \"private\";\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === \"public\";\n}\nconst SUPPORTED_JWS_ALGS = [\n    \"PS256\",\n    \"ES256\",\n    \"RS256\",\n    \"PS384\",\n    \"ES384\",\n    \"RS384\",\n    \"PS512\",\n    \"ES512\",\n    \"RS512\",\n    \"EdDSA\"\n];\nfunction processDpopNonce(response) {\n    const url = new URL(response.url);\n    if (response.headers.has(\"dpop-nonce\")) {\n        dpopNonces.set(url.origin, response.headers.get(\"dpop-nonce\"));\n    }\n    return response;\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (input !== undefined && !(input instanceof Headers)) {\n        throw new TypeError('\"options.headers\" must be an instance of Headers');\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has(\"dpop\")) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === \"function\") {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== \"https:\" && issuerIdentifier.protocol !== \"http:\") {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch(options?.algorithm){\n        case undefined:\n        case \"oidc\":\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace(\"//\", \"/\");\n            break;\n        case \"oauth2\":\n            if (url.pathname === \"/\") {\n                url.pathname = `.well-known/oauth-authorization-server`;\n            } else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace(\"//\", \"/\");\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return fetch(url.href, {\n        headers,\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === \"string\" && input.length !== 0;\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, \"+\");\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\");\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\");\n    }\n}\nfunction getClockSkew(client) {\n    if (Number.isFinite(client[clockSkew])) {\n        return client[clockSkew];\n    }\n    return 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client[clockTolerance];\n    if (Number.isFinite(tolerance) && Math.sign(tolerance) !== -1) {\n        return tolerance;\n    }\n    return 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [\n            as.issuer,\n            as.token_endpoint\n        ],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nasync function privateKeyJwt(as, client, key, kid) {\n    return jwt({\n        alg: keyToJws(key),\n        kid\n    }, clientAssertion(as, client), key);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete(\"client_secret\");\n    body.delete(\"client_assertion_type\");\n    body.delete(\"client_assertion\");\n    switch(client.token_endpoint_auth_method){\n        case undefined:\n        case \"client_secret_basic\":\n            {\n                assertNoClientPrivateKey(\"client_secret_basic\", clientPrivateKey);\n                headers.set(\"authorization\", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n                break;\n            }\n        case \"client_secret_post\":\n            {\n                assertNoClientPrivateKey(\"client_secret_post\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_secret\", assertClientSecret(client.client_secret));\n                break;\n            }\n        case \"private_key_jwt\":\n            {\n                assertNoClientSecret(\"private_key_jwt\", client.client_secret);\n                if (clientPrivateKey === undefined) {\n                    throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n                }\n                const { key, kid } = getKeyAndKid(clientPrivateKey);\n                if (!isPrivateKey(key)) {\n                    throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n                }\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                body.set(\"client_assertion\", await privateKeyJwt(as, client, key, kid));\n                break;\n            }\n        case \"none\":\n            {\n                assertNoClientSecret(\"none\", client.client_secret);\n                assertNoClientPrivateKey(\"none\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                break;\n            }\n        default:\n            throw new UnsupportedOperationError(\"unsupported client token_endpoint_auth_method\");\n    }\n}\nasync function jwt(header, claimsSet, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(claimsSet)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    if (parameters.has(\"claims\")) {\n        const value = parameters.get(\"claims\");\n        if (value === \"[object Object]\") {\n            throw new OPE('\"claims\" parameter must be passed as a UTF-8 encoded JSON');\n        }\n        try {\n            claims.claims = JSON.parse(value);\n        } catch (cause) {\n            throw new OPE('failed to parse the \"claims\" parameter as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(claims.claims)) {\n            throw new OPE('\"claims\" parameter must be a top level object');\n        }\n    }\n    return jwt({\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    }, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const proof = await jwt({\n        alg: keyToJws(privateKey),\n        typ: \"dpop+jwt\",\n        jwk: await publicJwk(publicKey)\n    }, {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n    }, privateKey);\n    headers.set(\"dpop\", proof);\n}\nlet jwkCache;\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    if (jwkCache.has(key)) {\n        return jwkCache.get(key);\n    }\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv\n    };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.pushed_authorization_request_endpoint !== \"string\") {\n        throw new TypeError('\"as.pushed_authorization_request_endpoint\" must be a string');\n    }\n    const url = new URL(as.pushed_authorization_request_endpoint);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nfunction isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== \"object\" || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return {\n            scheme: scheme.toLowerCase(),\n            parameters: {}\n        };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, \"\");\n    const parameters = {};\n    for(let i = 1; i < arr.length; i += 2){\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while(arr[idx].slice(-1) !== '\"' && ++i < arr.length){\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, \"\").toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters\n    };\n}\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (!response.headers.has(\"www-authenticate\")) {\n        return undefined;\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)){\n        result.push([\n            scheme,\n            index\n        ]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others)=>{\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        } else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set(\"authorization\", `Bearer ${accessToken}`);\n    } else {\n        await dpopProofJwt(headers, options.DPoP, url, \"GET\", getClockSkew({\n            [clockSkew]: options?.clockSkew\n        }), accessToken);\n        headers.set(\"authorization\", `DPoP ${accessToken}`);\n    }\n    return fetch(url.href, {\n        body,\n        headers,\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.userinfo_endpoint !== \"string\") {\n        throw new TypeError('\"as.userinfo_endpoint\" must be a string');\n    }\n    const url = new URL(as.userinfo_endpoint);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return protectedResourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        clockSkew: getClockSkew(client)\n    });\n}\nlet jwksCache;\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    let jwks;\n    let age;\n    jwksCache || (jwksCache = new WeakMap());\n    if (jwksCache.has(as)) {\n        ;\n        ({ jwks, age } = jwksCache.get(as));\n        if (age >= 300) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        jwksCache.set(as, {\n            jwks,\n            iat: epochTime(),\n            get age () {\n                return epochTime() - this.iat;\n            }\n        });\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"EdDSA\" && !(jwk.crv === \"Ed25519\" || jwk.crv === \"Ed448\"):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE(\"error when selecting a JWT verification key, no applicable keys found\");\n    } else if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw new OPE(\"jwks_uri must only contain public keys\");\n    }\n    return key;\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as.issuer));\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE(\"JWT UserInfo Response expected\");\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return fetch(url.href, {\n        body,\n        headers,\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    if (typeof as.token_endpoint !== \"string\") {\n        throw new TypeError('\"as.token_endpoint\" must be a string');\n    }\n    const url = new URL(as.token_endpoint);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, parameters, headers, options);\n}\nasync function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims;\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\");\n    }\n    if (json.expires_in !== undefined && (typeof json.expires_in !== \"number\" || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken && json.refresh_token !== undefined && !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n                \"aud\",\n                \"exp\",\n                \"iat\",\n                \"iss\",\n                \"sub\"\n            ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n                throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n            }\n            if (client.require_auth_time && typeof claims.auth_time !== \"number\") {\n                throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n            }\n            idTokenClaims.set(json, claims);\n        }\n    }\n    return json;\n}\nasync function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    } else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nasync function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code_verifier\", codeVerifier);\n    parameters.set(\"code\", code);\n    return tokenEndpointRequest(as, client, \"authorization_code\", parameters, options);\n}\nconst claimNames = {\n    aud: \"audience\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    sub: \"subject\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${claimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    switch(expectedNonce){\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === \"string\" && result.id_token.length) {\n            throw new OPE(\"Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing\");\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nasync function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    if (typeof as.revocation_endpoint !== \"string\") {\n        throw new TypeError('\"as.revocation_endpoint\" must be a string');\n    }\n    const url = new URL(as.revocation_endpoint);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nasync function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    if (typeof as.introspection_endpoint !== \"string\") {\n        throw new TypeError('\"as.introspection_endpoint\" must be a string');\n    }\n    const url = new URL(as.introspection_endpoint);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    } else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const url = new URL(as.jwks_uri);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return fetch(url.href, {\n        headers,\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== \"string\") {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== \"string\") {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== \"string\") {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== \"string\") {\n                    delete json.scope;\n                }\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch(namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key.algorithm);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case \"Ed448\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance) {\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\");\n    if (length === 5) {\n        throw new UnsupportedOperationError(\"JWE structure JWTs are not supported\");\n    }\n    if (length !== 3) {\n        throw new OPE(\"Invalid JWT\");\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Header body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE(\"JWT Header must be a top level object\");\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    if (getKey !== noSignatureCheck) {\n        const key = await getKey(header);\n        const input = `${protectedHeader}.${payload}`;\n        const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n        if (!verified) {\n            throw new OPE(\"JWT signature verification failed\");\n        }\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE(\"JWT Payload must be a top level object\");\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return {\n        header,\n        claims,\n        signature\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== \"RS256\") {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, \"error_description\"),\n            error_uri: getURLSearchParameter(parameters, \"error_uri\")\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        return crv;\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg, jwk.crv), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.device_authorization_endpoint !== \"string\") {\n        throw new TypeError('\"as.device_authorization_endpoint\" must be a string');\n    }\n    const url = new URL(as.device_authorization_endpoint);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined && !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== \"number\" || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nasync function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === \"EdDSA\" ? options?.crv ?? \"Ed25519\" : undefined);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vYXV0aDR3ZWJhcGkvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUE7QUFDSixJQUFJLE9BQU9DLGNBQWMsZUFBZSxDQUFDQSxVQUFVQyxTQUFTLEVBQUVDLGFBQWEsaUJBQWlCO0lBQ3hGLE1BQU1DLE9BQU87SUFDYixNQUFNQyxVQUFVO0lBQ2hCTCxhQUFhLENBQUMsRUFBRUksS0FBSyxDQUFDLEVBQUVDLFFBQVEsQ0FBQztBQUNyQztBQUNPLE1BQU1DLFlBQVlDLFNBQVM7QUFDM0IsTUFBTUMsaUJBQWlCRCxTQUFTO0FBQ3ZDLE1BQU1FLFVBQVUsSUFBSUM7QUFDcEIsTUFBTUMsVUFBVSxJQUFJQztBQUNwQixTQUFTQyxJQUFJQyxLQUFLO0lBQ2QsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBT0wsUUFBUU0sTUFBTSxDQUFDRDtJQUMxQjtJQUNBLE9BQU9ILFFBQVFLLE1BQU0sQ0FBQ0Y7QUFDMUI7QUFDQSxNQUFNRyxhQUFhO0FBQ25CLFNBQVNDLGdCQUFnQkosS0FBSztJQUMxQixJQUFJQSxpQkFBaUJLLGFBQWE7UUFDOUJMLFFBQVEsSUFBSU0sV0FBV047SUFDM0I7SUFDQSxNQUFNTyxNQUFNLEVBQUU7SUFDZCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVIsTUFBTVMsVUFBVSxFQUFFRCxLQUFLTCxXQUFZO1FBQ25ESSxJQUFJRyxJQUFJLENBQUNDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU1iLE1BQU1jLFFBQVEsQ0FBQ04sR0FBR0EsSUFBSUw7SUFDbkU7SUFDQSxPQUFPWSxLQUFLUixJQUFJUyxJQUFJLENBQUMsS0FBS0MsT0FBTyxDQUFDLE1BQU0sSUFBSUEsT0FBTyxDQUFDLE9BQU8sS0FBS0EsT0FBTyxDQUFDLE9BQU87QUFDbkY7QUFDQSxTQUFTQyxnQkFBZ0Js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YXV0aDR3ZWJhcGkvYnVpbGQvaW5kZXguanM/M2Q0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgVVNFUl9BR0VOVDtcbmlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLnVzZXJBZ2VudD8uc3RhcnRzV2l0aD8uKCdNb3ppbGxhLzUuMCAnKSkge1xuICAgIGNvbnN0IE5BTUUgPSAnb2F1dGg0d2ViYXBpJztcbiAgICBjb25zdCBWRVJTSU9OID0gJ3YyLjQuMCc7XG4gICAgVVNFUl9BR0VOVCA9IGAke05BTUV9LyR7VkVSU0lPTn1gO1xufVxuZXhwb3J0IGNvbnN0IGNsb2NrU2tldyA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGNsb2NrVG9sZXJhbmNlID0gU3ltYm9sKCk7XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBidWYoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoaW5wdXQpO1xufVxuY29uc3QgQ0hVTktfU0laRSA9IDB4ODAwMDtcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NFVybChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH1cbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmJ5dGVMZW5ndGg7IGkgKz0gQ0hVTktfU0laRSkge1xuICAgICAgICBhcnIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlucHV0LnN1YmFycmF5KGksIGkgKyBDSFVOS19TSVpFKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShhcnIuam9pbignJykpLnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xufVxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0VXJsKGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmluYXJ5ID0gYXRvYihpbnB1dC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdUaGUgaW5wdXQgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuJywgeyBjYXVzZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBiNjR1KGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZUJhc2U2NFVybChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVCYXNlNjRVcmwoaW5wdXQpO1xufVxuY2xhc3MgTFJVIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhTaXplKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodiA9IHRoaXMuX2NhY2hlLmdldChrZXkpKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoa2V5LCB2KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSkgfHwgdGhpcy5fY2FjaGUuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmNvbnN0IE9QRSA9IE9wZXJhdGlvblByb2Nlc3NpbmdFcnJvcjtcbmNvbnN0IGRwb3BOb25jZXMgPSBuZXcgTFJVKDEwMCk7XG5mdW5jdGlvbiBpc0NyeXB0b0tleShrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5O1xufVxuZnVuY3Rpb24gaXNQcml2YXRlS2V5KGtleSkge1xuICAgIHJldHVybiBpc0NyeXB0b0tleShrZXkpICYmIGtleS50eXBlID09PSAncHJpdmF0ZSc7XG59XG5mdW5jdGlvbiBpc1B1YmxpY0tleShrZXkpIHtcbiAgICByZXR1cm4gaXNDcnlwdG9LZXkoa2V5KSAmJiBrZXkudHlwZSA9PT0gJ3B1YmxpYyc7XG59XG5jb25zdCBTVVBQT1JURURfSldTX0FMR1MgPSBbXG4gICAgJ1BTMjU2JyxcbiAgICAnRVMyNTYnLFxuICAgICdSUzI1NicsXG4gICAgJ1BTMzg0JyxcbiAgICAnRVMzODQnLFxuICAgICdSUzM4NCcsXG4gICAgJ1BTNTEyJyxcbiAgICAnRVM1MTInLFxuICAgICdSUzUxMicsXG4gICAgJ0VkRFNBJyxcbl07XG5mdW5jdGlvbiBwcm9jZXNzRHBvcE5vbmNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXNwb25zZS51cmwpO1xuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmhhcygnZHBvcC1ub25jZScpKSB7XG4gICAgICAgIGRwb3BOb25jZXMuc2V0KHVybC5vcmlnaW4sIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdkcG9wLW5vbmNlJykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUeXAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eYXBwbGljYXRpb25cXC8vLCAnJyk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcHJlcGFyZUhlYWRlcnMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiAhKGlucHV0IGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmhlYWRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhlYWRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0KTtcbiAgICBpZiAoVVNFUl9BR0VOVCAmJiAhaGVhZGVycy5oYXMoJ3VzZXItYWdlbnQnKSkge1xuICAgICAgICBoZWFkZXJzLnNldCgndXNlci1hZ2VudCcsIFVTRVJfQUdFTlQpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVycy5oYXMoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuaGVhZGVyc1wiIG11c3Qgbm90IGluY2x1ZGUgdGhlIFwiYXV0aG9yaXphdGlvblwiIGhlYWRlciBuYW1lJyk7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzLmhhcygnZHBvcCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5oZWFkZXJzXCIgbXVzdCBub3QgaW5jbHVkZSB0aGUgXCJkcG9wXCIgaGVhZGVyIG5hbWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBzaWduYWwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLnNpZ25hbFwiIG11c3QgcmV0dXJuIG9yIGJlIGFuIGluc3RhbmNlIG9mIEFib3J0U2lnbmFsJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNjb3ZlcnlSZXF1ZXN0KGlzc3VlcklkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShpc3N1ZXJJZGVudGlmaWVyIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlzc3VlcklkZW50aWZpZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoaXNzdWVySWRlbnRpZmllci5wcm90b2NvbCAhPT0gJ2h0dHBzOicgJiYgaXNzdWVySWRlbnRpZmllci5wcm90b2NvbCAhPT0gJ2h0dHA6Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlzc3Vlci5wcm90b2NvbFwiIG11c3QgYmUgXCJodHRwczpcIiBvciBcImh0dHA6XCInKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChpc3N1ZXJJZGVudGlmaWVyLmhyZWYpO1xuICAgIHN3aXRjaCAob3B0aW9ucz8uYWxnb3JpdGhtKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdvaWRjJzpcbiAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAke3VybC5wYXRobmFtZX0vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYXV0aDInOlxuICAgICAgICAgICAgaWYgKHVybC5wYXRobmFtZSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgdXJsLnBhdGhuYW1lID0gYC53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlci8ke3VybC5wYXRobmFtZX1gLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmFsZ29yaXRobVwiIG11c3QgYmUgXCJvaWRjXCIgKGRlZmF1bHQpLCBvciBcIm9hdXRoMlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIGlucHV0Lmxlbmd0aCAhPT0gMDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UoZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyLCByZXNwb25zZSkge1xuICAgIGlmICghKGV4cGVjdGVkSXNzdWVySWRlbnRpZmllciBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHBlY3RlZElzc3VlclwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJyk7XG4gICAgfVxuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBBdXRob3JpemF0aW9uIFNlcnZlciBNZXRhZGF0YSByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uaXNzdWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlzc3VlclwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChuZXcgVVJMKGpzb24uaXNzdWVyKS5ocmVmICE9PSBleHBlY3RlZElzc3VlcklkZW50aWZpZXIuaHJlZikge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlzc3VlclwiIGRvZXMgbm90IG1hdGNoIFwiZXhwZWN0ZWRJc3N1ZXJcIicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKCkge1xuICAgIHJldHVybiBiNjR1KGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Db2RlVmVyaWZpZXIoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdGF0ZSgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbU5vbmNlKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZVBLQ0VDb2RlQ2hhbGxlbmdlKGNvZGVWZXJpZmllcikge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY29kZVZlcmlmaWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNvZGVWZXJpZmllclwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGNvZGVWZXJpZmllcikpKTtcbn1cbmZ1bmN0aW9uIGdldEtleUFuZEtpZChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENyeXB0b0tleSkge1xuICAgICAgICByZXR1cm4geyBrZXk6IGlucHV0IH07XG4gICAgfVxuICAgIGlmICghKGlucHV0Py5rZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmtpZCAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0ZVN0cmluZyhpbnB1dC5raWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wia2lkXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsga2V5OiBpbnB1dC5rZXksIGtpZDogaW5wdXQua2lkIH07XG59XG5mdW5jdGlvbiBmb3JtVXJsRW5jb2RlKHRva2VuKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0b2tlbikucmVwbGFjZSgvJTIwL2csICcrJyk7XG59XG5mdW5jdGlvbiBjbGllbnRTZWNyZXRCYXNpYyhjbGllbnRJZCwgY2xpZW50U2VjcmV0KSB7XG4gICAgY29uc3QgdXNlcm5hbWUgPSBmb3JtVXJsRW5jb2RlKGNsaWVudElkKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IGZvcm1VcmxFbmNvZGUoY2xpZW50U2VjcmV0KTtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGJ0b2EoYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCk7XG4gICAgcmV0dXJuIGBCYXNpYyAke2NyZWRlbnRpYWxzfWA7XG59XG5mdW5jdGlvbiBwc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzI1Nic7XG4gICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzM4NCc7XG4gICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgcmV0dXJuICdQUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgUnNhSGFzaGVkS2V5QWxnb3JpdGhtIGhhc2ggbmFtZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMjU2JztcbiAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMzg0JztcbiAgICAgICAgY2FzZSAnU0hBLTUxMic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBSc2FIYXNoZWRLZXlBbGdvcml0aG0gaGFzaCBuYW1lJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpIHtcbiAgICAgICAgY2FzZSAnUC0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnRVMzODQnO1xuICAgICAgICBjYXNlICdQLTUyMSc6XG4gICAgICAgICAgICByZXR1cm4gJ0VTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBFY0tleUFsZ29yaXRobSBuYW1lZEN1cnZlJyk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9Kd3Moa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6XG4gICAgICAgICAgICByZXR1cm4gcHNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnUlNBU1NBLVBLQ1MxLXYxXzUnOlxuICAgICAgICAgICAgcmV0dXJuIHJzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ0VDRFNBJzpcbiAgICAgICAgICAgIHJldHVybiBlc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICAgICAgcmV0dXJuICdFZERTQSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgQ3J5cHRvS2V5IGFsZ29yaXRobSBuYW1lJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2xvY2tTa2V3KGNsaWVudCkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY2xpZW50W2Nsb2NrU2tld10pKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRbY2xvY2tTa2V3XTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpIHtcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBjbGllbnRbY2xvY2tUb2xlcmFuY2VdO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodG9sZXJhbmNlKSAmJiBNYXRoLnNpZ24odG9sZXJhbmNlKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvbGVyYW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIDMwO1xufVxuZnVuY3Rpb24gZXBvY2hUaW1lKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbn1cbmZ1bmN0aW9uIGNsaWVudEFzc2VydGlvbihhcywgY2xpZW50KSB7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBqdGk6IHJhbmRvbUJ5dGVzKCksXG4gICAgICAgIGF1ZDogW2FzLmlzc3VlciwgYXMudG9rZW5fZW5kcG9pbnRdLFxuICAgICAgICBleHA6IG5vdyArIDYwLFxuICAgICAgICBpYXQ6IG5vdyxcbiAgICAgICAgbmJmOiBub3csXG4gICAgICAgIGlzczogY2xpZW50LmNsaWVudF9pZCxcbiAgICAgICAgc3ViOiBjbGllbnQuY2xpZW50X2lkLFxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBwcml2YXRlS2V5Snd0KGFzLCBjbGllbnQsIGtleSwga2lkKSB7XG4gICAgcmV0dXJuIGp3dCh7XG4gICAgICAgIGFsZzoga2V5VG9Kd3Moa2V5KSxcbiAgICAgICAga2lkLFxuICAgIH0sIGNsaWVudEFzc2VydGlvbihhcywgY2xpZW50KSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzKGFzKSB7XG4gICAgaWYgKHR5cGVvZiBhcyAhPT0gJ29iamVjdCcgfHwgYXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhc1wiIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoYXMuaXNzdWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmlzc3VlclwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xpZW50KGNsaWVudCkge1xuICAgIGlmICh0eXBlb2YgY2xpZW50ICE9PSAnb2JqZWN0JyB8fCBjbGllbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjbGllbnRcIiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNsaWVudC5jbGllbnRfaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2xpZW50LmNsaWVudF9pZFwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xpZW50U2VjcmV0KGNsaWVudFNlY3JldCkge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY2xpZW50U2VjcmV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNsaWVudC5jbGllbnRfc2VjcmV0XCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudFNlY3JldDtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleShjbGllbnRBdXRoTWV0aG9kLCBjbGllbnRQcml2YXRlS2V5KSB7XG4gICAgaWYgKGNsaWVudFByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleVwiIHByb3BlcnR5IG11c3Qgbm90IGJlIHByb3ZpZGVkIHdoZW4gJHtjbGllbnRBdXRoTWV0aG9kfSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIGlzIHVzZWQuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Tm9DbGllbnRTZWNyZXQoY2xpZW50QXV0aE1ldGhvZCwgY2xpZW50U2VjcmV0KSB7XG4gICAgaWYgKGNsaWVudFNlY3JldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiY2xpZW50LmNsaWVudF9zZWNyZXRcIiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBwcm92aWRlZCB3aGVuICR7Y2xpZW50QXV0aE1ldGhvZH0gY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBpcyB1c2VkLmApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNsaWVudEF1dGhlbnRpY2F0aW9uKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMsIGNsaWVudFByaXZhdGVLZXkpIHtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X3NlY3JldCcpO1xuICAgIGJvZHkuZGVsZXRlKCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnKTtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X2Fzc2VydGlvbicpO1xuICAgIHN3aXRjaCAoY2xpZW50LnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdjbGllbnRfc2VjcmV0X2Jhc2ljJzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5KCdjbGllbnRfc2VjcmV0X2Jhc2ljJywgY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGNsaWVudFNlY3JldEJhc2ljKGNsaWVudC5jbGllbnRfaWQsIGFzc2VydENsaWVudFNlY3JldChjbGllbnQuY2xpZW50X3NlY3JldCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfcG9zdCc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSgnY2xpZW50X3NlY3JldF9wb3N0JywgY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X3NlY3JldCcsIGFzc2VydENsaWVudFNlY3JldChjbGllbnQuY2xpZW50X3NlY3JldCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncHJpdmF0ZV9rZXlfand0Jzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRTZWNyZXQoJ3ByaXZhdGVfa2V5X2p3dCcsIGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIGlmIChjbGllbnRQcml2YXRlS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleVwiIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBcImNsaWVudC50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZFwiIGlzIFwicHJpdmF0ZV9rZXlfand0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCBraWQgfSA9IGdldEtleUFuZEtpZChjbGllbnRQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGlmICghaXNQcml2YXRlS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleS5rZXlcIiBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnLCAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2Fzc2VydGlvbicsIGF3YWl0IHByaXZhdGVLZXlKd3QoYXMsIGNsaWVudCwga2V5LCBraWQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOiB7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFNlY3JldCgnbm9uZScsIGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSgnbm9uZScsIGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBjbGllbnQgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QnKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBqd3QoaGVhZGVyLCBjbGFpbXNTZXQsIGtleSkge1xuICAgIGlmICgha2V5LnVzYWdlcy5pbmNsdWRlcygnc2lnbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NyeXB0b0tleSBpbnN0YW5jZXMgdXNlZCBmb3Igc2lnbmluZyBhc3NlcnRpb25zIG11c3QgaW5jbHVkZSBcInNpZ25cIiBpbiB0aGVpciBcInVzYWdlc1wiJyk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gYCR7YjY0dShidWYoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSkpfS4ke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KGNsYWltc1NldCkpKX1gO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKGtleVRvU3VidGxlKGtleSksIGtleSwgYnVmKGlucHV0KSkpO1xuICAgIHJldHVybiBgJHtpbnB1dH0uJHtzaWduYXR1cmV9YDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc3N1ZVJlcXVlc3RPYmplY3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgcHJpdmF0ZUtleSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCB7IGtleSwga2lkIH0gPSBnZXRLZXlBbmRLaWQocHJpdmF0ZUtleSk7XG4gICAgaWYgKCFpc1ByaXZhdGVLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInByaXZhdGVLZXkua2V5XCIgbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5Jyk7XG4gICAgfVxuICAgIHBhcmFtZXRlcnMuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgIGNvbnN0IGNsYWltcyA9IHtcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtZXRlcnMuZW50cmllcygpKSxcbiAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICBhdWQ6IGFzLmlzc3VlcixcbiAgICAgICAgZXhwOiBub3cgKyA2MCxcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIG5iZjogbm93LFxuICAgICAgICBpc3M6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgfTtcbiAgICBsZXQgcmVzb3VyY2U7XG4gICAgaWYgKHBhcmFtZXRlcnMuaGFzKCdyZXNvdXJjZScpICYmXG4gICAgICAgIChyZXNvdXJjZSA9IHBhcmFtZXRlcnMuZ2V0QWxsKCdyZXNvdXJjZScpKSAmJlxuICAgICAgICByZXNvdXJjZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYWltcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVycy5oYXMoJ2NsYWltcycpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1ldGVycy5nZXQoJ2NsYWltcycpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImNsYWltc1wiIHBhcmFtZXRlciBtdXN0IGJlIHBhc3NlZCBhcyBhIFVURi04IGVuY29kZWQgSlNPTicpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGFpbXMuY2xhaW1zID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgdGhlIFwiY2xhaW1zXCIgcGFyYW1ldGVyIGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcy5jbGFpbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImNsYWltc1wiIHBhcmFtZXRlciBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqd3Qoe1xuICAgICAgICBhbGc6IGtleVRvSndzKGtleSksXG4gICAgICAgIHR5cDogJ29hdXRoLWF1dGh6LXJlcStqd3QnLFxuICAgICAgICBraWQsXG4gICAgfSwgY2xhaW1zLCBrZXkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMsIHVybCwgaHRtLCBjbG9ja1NrZXcsIGFjY2Vzc1Rva2VuKSB7XG4gICAgY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXksIG5vbmNlID0gZHBvcE5vbmNlcy5nZXQodXJsLm9yaWdpbikgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFpc1ByaXZhdGVLZXkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QLnByaXZhdGVLZXlcIiBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXknKTtcbiAgICB9XG4gICAgaWYgKCFpc1B1YmxpY0tleShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5wdWJsaWNLZXlcIiBtdXN0IGJlIGEgcHVibGljIENyeXB0b0tleScpO1xuICAgIH1cbiAgICBpZiAobm9uY2UgIT09IHVuZGVmaW5lZCAmJiAhdmFsaWRhdGVTdHJpbmcobm9uY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5ub25jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoIXB1YmxpY0tleS5leHRyYWN0YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1AucHVibGljS2V5LmV4dHJhY3RhYmxlXCIgbXVzdCBiZSB0cnVlJyk7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGNvbnN0IHByb29mID0gYXdhaXQgand0KHtcbiAgICAgICAgYWxnOiBrZXlUb0p3cyhwcml2YXRlS2V5KSxcbiAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxuICAgICAgICBqd2s6IGF3YWl0IHB1YmxpY0p3ayhwdWJsaWNLZXkpLFxuICAgIH0sIHtcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgaHRtLFxuICAgICAgICBub25jZSxcbiAgICAgICAgaHR1OiBgJHt1cmwub3JpZ2lufSR7dXJsLnBhdGhuYW1lfWAsXG4gICAgICAgIGF0aDogYWNjZXNzVG9rZW4gPyBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGFjY2Vzc1Rva2VuKSkpIDogdW5kZWZpbmVkLFxuICAgIH0sIHByaXZhdGVLZXkpO1xuICAgIGhlYWRlcnMuc2V0KCdkcG9wJywgcHJvb2YpO1xufVxubGV0IGp3a0NhY2hlO1xuYXN5bmMgZnVuY3Rpb24gcHVibGljSndrKGtleSkge1xuICAgIGp3a0NhY2hlIHx8IChqd2tDYWNoZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAgIGlmIChqd2tDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gandrQ2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYgfSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBrZXkpO1xuICAgIGNvbnN0IGp3ayA9IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYgfTtcbiAgICBqd2tDYWNoZS5zZXQoa2V5LCBqd2spO1xuICAgIHJldHVybiBqd2s7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHVzaGVkQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAodHlwZW9mIGFzLnB1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMucHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdF9lbmRwb2ludFwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChhcy5wdXNoZWRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2VuZHBvaW50KTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnUE9TVCcsIGdldENsb2NrU2tldyhjbGllbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09BdXRoMkVycm9yKGlucHV0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBpbnB1dDtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5lcnJvciAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMiAmJiB2YWx1ZVswXSA9PT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBTUExJVF9SRUdFWFAgPSAvKCg/Oix8LCApP1swLTlhLXpBLVohIyQlJicqKy0uXl9gfH5dKz0pLztcbmNvbnN0IFNDSEVNRVNfUkVHRVhQID0gLyg/Ol58LCA/KShbMC05YS16QS1aISMkJSYnKitcXC0uXl9gfH5dKykoPz0kfFsgLF0pL2c7XG5mdW5jdGlvbiB3d3dBdXRoKHNjaGVtZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgYXJyID0gcGFyYW1zLnNwbGl0KFNQTElUX1JFR0VYUCkuc2xpY2UoMSk7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtZTogc2NoZW1lLnRvTG93ZXJDYXNlKCksIHBhcmFtZXRlcnM6IHt9IH07XG4gICAgfVxuICAgIGFyclthcnIubGVuZ3RoIC0gMV0gPSBhcnJbYXJyLmxlbmd0aCAtIDFdLnJlcGxhY2UoLywkLywgJycpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBpZHggPSBpO1xuICAgICAgICBpZiAoYXJyW2lkeF1bMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChhcnJbaWR4XS5zbGljZSgtMSkgIT09ICdcIicgJiYgKytpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFycltpZHhdICs9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBhcnJbaWR4IC0gMV0ucmVwbGFjZSgvXig/OiwgPyl8PSQvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBhcmFtZXRlcnNba2V5XSA9IHVucXVvdGUoYXJyW2lkeF0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwYXJhbWV0ZXJzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VXd3dBdXRoZW50aWNhdGVDaGFsbGVuZ2VzKHJlc3BvbnNlKSB7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5oZWFkZXJzLmhhcygnd3d3LWF1dGhlbnRpY2F0ZScpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCB7IDE6IHNjaGVtZSwgaW5kZXggfSBvZiBoZWFkZXIubWF0Y2hBbGwoU0NIRU1FU19SRUdFWFApKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtzY2hlbWUsIGluZGV4XSk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gcmVzdWx0Lm1hcCgoW3NjaGVtZSwgaW5kZXhPZl0sIGksIG90aGVycykgPT4ge1xuICAgICAgICBjb25zdCBuZXh0ID0gb3RoZXJzW2kgKyAxXTtcbiAgICAgICAgbGV0IHBhcmFtZXRlcnM7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0gaGVhZGVyLnNsaWNlKGluZGV4T2YsIG5leHRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IGhlYWRlci5zbGljZShpbmRleE9mKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3d3QXV0aChzY2hlbWUsIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGFsbGVuZ2VzO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NQdXNoZWRBdXRob3JpemF0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAxKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBQdXNoZWQgQXV0aG9yaXphdGlvbiBSZXF1ZXN0IEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5yZXF1ZXN0X3VyaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJyZXF1ZXN0X3VyaVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyB8fCBqc29uLmV4cGlyZXNfaW4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb3RlY3RlZFJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgbWV0aG9kLCB1cmwsIGhlYWRlcnMsIGJvZHksIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFjY2Vzc1Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFjY2Vzc1Rva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInVybFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJyk7XG4gICAgfVxuICAgIGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhoZWFkZXJzKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhdXRob3JpemF0aW9uJywgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnR0VUJywgZ2V0Q2xvY2tTa2V3KHsgW2Nsb2NrU2tld106IG9wdGlvbnM/LmNsb2NrU2tldyB9KSwgYWNjZXNzVG9rZW4pO1xuICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGBEUG9QICR7YWNjZXNzVG9rZW59YCk7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaCh1cmwuaHJlZiwge1xuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgPyBzaWduYWwob3B0aW9ucy5zaWduYWwpIDogbnVsbCxcbiAgICB9KS50aGVuKHByb2Nlc3NEcG9wTm9uY2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVzZXJJbmZvUmVxdWVzdChhcywgY2xpZW50LCBhY2Nlc3NUb2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAodHlwZW9mIGFzLnVzZXJpbmZvX2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLnVzZXJpbmZvX2VuZHBvaW50XCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFzLnVzZXJpbmZvX2VuZHBvaW50KTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vand0Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qd3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3RlY3RlZFJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgJ0dFVCcsIHVybCwgaGVhZGVycywgbnVsbCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBjbG9ja1NrZXc6IGdldENsb2NrU2tldyhjbGllbnQpLFxuICAgIH0pO1xufVxubGV0IGp3a3NDYWNoZTtcbmFzeW5jIGZ1bmN0aW9uIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpIHtcbiAgICBjb25zdCB7IGFsZywga2lkIH0gPSBoZWFkZXI7XG4gICAgY2hlY2tTdXBwb3J0ZWRKd3NBbGcoYWxnKTtcbiAgICBsZXQgandrcztcbiAgICBsZXQgYWdlO1xuICAgIGp3a3NDYWNoZSB8fCAoandrc0NhY2hlID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgaWYgKGp3a3NDYWNoZS5oYXMoYXMpKSB7XG4gICAgICAgIDtcbiAgICAgICAgKHsgandrcywgYWdlIH0gPSBqd2tzQ2FjaGUuZ2V0KGFzKSk7XG4gICAgICAgIGlmIChhZ2UgPj0gMzAwKSB7XG4gICAgICAgICAgICBqd2tzQ2FjaGUuZGVsZXRlKGFzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgandrcyA9IGF3YWl0IGp3a3NSZXF1ZXN0KGFzLCBvcHRpb25zKS50aGVuKHByb2Nlc3NKd2tzUmVzcG9uc2UpO1xuICAgICAgICBhZ2UgPSAwO1xuICAgICAgICBqd2tzQ2FjaGUuc2V0KGFzLCB7XG4gICAgICAgICAgICBqd2tzLFxuICAgICAgICAgICAgaWF0OiBlcG9jaFRpbWUoKSxcbiAgICAgICAgICAgIGdldCBhZ2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVwb2NoVGltZSgpIC0gdGhpcy5pYXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGt0eTtcbiAgICBzd2l0Y2ggKGFsZy5zbGljZSgwLCAyKSkge1xuICAgICAgICBjYXNlICdSUyc6XG4gICAgICAgIGNhc2UgJ1BTJzpcbiAgICAgICAgICAgIGt0eSA9ICdSU0EnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VTJzpcbiAgICAgICAgICAgIGt0eSA9ICdFQyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRWQnOlxuICAgICAgICAgICAga3R5ID0gJ09LUCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBqd2tzLmtleXMuZmlsdGVyKChqd2spID0+IHtcbiAgICAgICAgaWYgKGp3ay5rdHkgIT09IGt0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChraWQgIT09IHVuZGVmaW5lZCAmJiBraWQgIT09IGp3ay5raWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmFsZyAhPT0gdW5kZWZpbmVkICYmIGFsZyAhPT0gandrLmFsZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqd2sudXNlICE9PSB1bmRlZmluZWQgJiYgandrLnVzZSAhPT0gJ3NpZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmtleV9vcHM/LmluY2x1ZGVzKCd2ZXJpZnknKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVMyNTYnICYmIGp3ay5jcnYgIT09ICdQLTI1Nic6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTMzg0JyAmJiBqd2suY3J2ICE9PSAnUC0zODQnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzUxMicgJiYgandrLmNydiAhPT0gJ1AtNTIxJzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRWREU0EnICYmICEoandrLmNydiA9PT0gJ0VkMjU1MTknIHx8IGp3ay5jcnYgPT09ICdFZDQ0OCcpOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB7IDA6IGp3aywgbGVuZ3RoIH0gPSBjYW5kaWRhdGVzO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGlmIChhZ2UgPj0gNjApIHtcbiAgICAgICAgICAgIGp3a3NDYWNoZS5kZWxldGUoYXMpO1xuICAgICAgICAgICAgcmV0dXJuIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2Vycm9yIHdoZW4gc2VsZWN0aW5nIGEgSldUIHZlcmlmaWNhdGlvbiBrZXksIG5vIGFwcGxpY2FibGUga2V5cyBmb3VuZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZXJyb3Igd2hlbiBzZWxlY3RpbmcgYSBKV1QgdmVyaWZpY2F0aW9uIGtleSwgbXVsdGlwbGUgYXBwbGljYWJsZSBrZXlzIGZvdW5kLCBhIFwia2lkXCIgSldUIEhlYWRlciBQYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgaW1wb3J0SndrKGFsZywgandrKTtcbiAgICBpZiAoa2V5LnR5cGUgIT09ICdwdWJsaWMnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2p3a3NfdXJpIG11c3Qgb25seSBjb250YWluIHB1YmxpYyBrZXlzJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG59XG5leHBvcnQgY29uc3Qgc2tpcFN1YmplY3RDaGVjayA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpPy5zcGxpdCgnOycpWzBdO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVc2VySW5mb1Jlc3BvbnNlKGFzLCBjbGllbnQsIGV4cGVjdGVkU3ViamVjdCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFVzZXJJbmZvIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGxldCBqc29uO1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi9qd3QnKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYXdhaXQgcmVzcG9uc2UudGV4dCgpLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy51c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVPcHRpb25hbElzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSk7XG4gICAgICAgIGpzb24gPSBjbGFpbXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBVc2VySW5mbyBSZXNwb25zZSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uc3ViKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInN1YlwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWRTdWJqZWN0KSB7XG4gICAgICAgIGNhc2Ugc2tpcFN1YmplY3RDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZFN1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJleHBlY3RlZFN1YmplY3RcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uc3ViICE9PSBleHBlY3RlZFN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIFwicmVzcG9uc2VcIiBib2R5IFwic3ViXCIgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCBtZXRob2QsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICAgIGF3YWl0IGNsaWVudEF1dGhlbnRpY2F0aW9uKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnM/LmNsaWVudFByaXZhdGVLZXkpO1xuICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGdyYW50VHlwZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgYXMudG9rZW5fZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMudG9rZW5fZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMudG9rZW5fZW5kcG9pbnQpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdncmFudF90eXBlJywgZ3JhbnRUeXBlKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBkcG9wUHJvb2ZKd3QoaGVhZGVycywgb3B0aW9ucy5EUG9QLCB1cmwsICdQT1NUJywgZ2V0Q2xvY2tTa2V3KGNsaWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIHBhcmFtZXRlcnMsIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdChhcywgY2xpZW50LCByZWZyZXNoVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhyZWZyZXNoVG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVmcmVzaFRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdyZWZyZXNoX3Rva2VuJywgcmVmcmVzaFRva2VuKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ3JlZnJlc2hfdG9rZW4nLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbn1cbmNvbnN0IGlkVG9rZW5DbGFpbXMgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVmKSB7XG4gICAgaWYgKCFyZWYuaWRfdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY2xhaW1zID0gaWRUb2tlbkNsYWltcy5nZXQocmVmKTtcbiAgICBpZiAoIWNsYWltcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlZlwiIHdhcyBhbHJlYWR5IGdhcmJhZ2UgY29sbGVjdGVkIG9yIGRpZCBub3QgcmVzb2x2ZSBmcm9tIHRoZSBwcm9wZXIgc291cmNlcycpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhaW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBpZ25vcmVJZFRva2VuID0gZmFsc2UsIGlnbm9yZVJlZnJlc2hUb2tlbiA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gVG9rZW4gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmFjY2Vzc190b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJhY2Nlc3NfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24udG9rZW5fdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ0b2tlbl90eXBlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAganNvbi50b2tlbl90eXBlID0ganNvbi50b2tlbl90eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGpzb24udG9rZW5fdHlwZSAhPT0gJ2Rwb3AnICYmIGpzb24udG9rZW5fdHlwZSAhPT0gJ2JlYXJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIGB0b2tlbl90eXBlYCB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAoanNvbi5leHBpcmVzX2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInIHx8IGpzb24uZXhwaXJlc19pbiA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmICghaWdub3JlUmVmcmVzaFRva2VuICYmXG4gICAgICAgIGpzb24ucmVmcmVzaF90b2tlbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF2YWxpZGF0ZVN0cmluZyhqc29uLnJlZnJlc2hfdG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwicmVmcmVzaF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChqc29uLnNjb3BlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uc2NvcGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwic2NvcGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghaWdub3JlSWRUb2tlbikge1xuICAgICAgICBpZiAoanNvbi5pZF90b2tlbiAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0ZVN0cmluZyhqc29uLmlkX3Rva2VuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpZF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uaWRfdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChqc29uLmlkX3Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5pZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnZXhwJywgJ2lhdCcsICdpc3MnLCAnc3ViJ10pKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNsYWltcy5hdWQpICYmIGNsYWltcy5hdWQubGVuZ3RoICE9PSAxICYmIGNsYWltcy5henAgIT09IGNsaWVudC5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXpwXCIgKGF1dGhvcml6ZWQgcGFydHkpIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpZW50LnJlcXVpcmVfYXV0aF90aW1lICYmIHR5cGVvZiBjbGFpbXMuYXV0aF90aW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJhdXRoX3RpbWVcIiAoYXV0aGVudGljYXRpb24gdGltZSkgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMuc2V0KGpzb24sIGNsYWltcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1JlZnJlc2hUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0LmNsYWltcy5hdWQpKSB7XG4gICAgICAgIGlmICghcmVzdWx0LmNsYWltcy5hdWQuaW5jbHVkZXMoZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQuY2xhaW1zLmF1ZCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsSXNzdWVyKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5pc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVJc3N1ZXIoZXhwZWN0ZWQsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUlzc3VlcihleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuaXNzICE9PSBleHBlY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlzc1wiIChpc3N1ZXIpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBicmFuZGVkID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGJyYW5kKHNlYXJjaFBhcmFtcykge1xuICAgIGJyYW5kZWQuYWRkKHNlYXJjaFBhcmFtcyk7XG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjYWxsYmFja1BhcmFtZXRlcnMsIHJlZGlyZWN0VXJpLCBjb2RlVmVyaWZpZXIsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFicmFuZGVkLmhhcyhjYWxsYmFja1BhcmFtZXRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tQYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMgb2J0YWluZWQgZnJvbSBcInZhbGlkYXRlQXV0aFJlc3BvbnNlKClcIiwgb3IgXCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSgpJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVkaXJlY3RVcmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVkaXJlY3RVcmlcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNvZGVWZXJpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjb2RlVmVyaWZpZXJcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKGNhbGxiYWNrUGFyYW1ldGVycywgJ2NvZGUnKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnbm8gYXV0aG9yaXphdGlvbiBjb2RlIGluIFwiY2FsbGJhY2tQYXJhbWV0ZXJzXCInKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdyZWRpcmVjdF91cmknLCByZWRpcmVjdFVyaSk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2NvZGVfdmVyaWZpZXInLCBjb2RlVmVyaWZpZXIpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdjb2RlJywgY29kZSk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdhdXRob3JpemF0aW9uX2NvZGUnLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbn1cbmNvbnN0IGNsYWltTmFtZXMgPSB7XG4gICAgYXVkOiAnYXVkaWVuY2UnLFxuICAgIGV4cDogJ2V4cGlyYXRpb24gdGltZScsXG4gICAgaWF0OiAnaXNzdWVkIGF0JyxcbiAgICBpc3M6ICdpc3N1ZXInLFxuICAgIHN1YjogJ3N1YmplY3QnLFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJlc2VuY2UocmVxdWlyZWQsIHJlc3VsdCkge1xuICAgIGZvciAoY29uc3QgY2xhaW0gb2YgcmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5jbGFpbXNbY2xhaW1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoYEpXVCBcIiR7Y2xhaW19XCIgKCR7Y2xhaW1OYW1lc1tjbGFpbV19KSBjbGFpbSBtaXNzaW5nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCBleHBlY3ROb05vbmNlID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3Qgc2tpcEF1dGhUaW1lQ2hlY2sgPSBTeW1ib2woKTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgbWF4QWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbiAgICBpZiAoaXNPQXV0aDJFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVzdWx0LmlkX3Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlkX3Rva2VuXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgbWF4QWdlID8/IChtYXhBZ2UgPSBjbGllbnQuZGVmYXVsdF9tYXhfYWdlID8/IHNraXBBdXRoVGltZUNoZWNrKTtcbiAgICBjb25zdCBjbGFpbXMgPSBnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlc3VsdCk7XG4gICAgaWYgKChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgfHwgbWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykgJiZcbiAgICAgICAgY2xhaW1zLmF1dGhfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0lEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpIGNsYWltIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgaWYgKG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInIHx8IG1heEFnZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5tYXhfYWdlXCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpO1xuICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSArIG1heEFnZSA8IG5vdyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWROb25jZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSBleHBlY3ROb05vbmNlOlxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZE5vbmNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXhwZWN0ZWROb25jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhaW1zLm5vbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gZXhwZWN0ZWROb25jZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHRydWUpO1xuICAgIGlmIChpc09BdXRoMkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5pZF90b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmlkX3Rva2VuID09PSAnc3RyaW5nJyAmJiByZXN1bHQuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdVbmV4cGVjdGVkIElEIFRva2VuIHJldHVybmVkLCB1c2UgcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT3BlbklEUmVzcG9uc2UoKSBmb3IgT3BlbklEIENvbm5lY3QgY2FsbGJhY2sgcHJvY2Vzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuaWRfdG9rZW47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGVja0p3dFR5cGUoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0LmhlYWRlci50eXAgIT09ICdzdHJpbmcnIHx8IG5vcm1hbGl6ZVR5cChyZXN1bHQuaGVhZGVyLnR5cCkgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwidHlwXCIgaGVhZGVyIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdjbGllbnRfY3JlZGVudGlhbHMnLCBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2xpZW50Q3JlZGVudGlhbHNSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKGlzT0F1dGgyRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldm9jYXRpb25SZXF1ZXN0KGFzLCBjbGllbnQsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcodG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widG9rZW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFzLnJldm9jYXRpb25fZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMucmV2b2NhdGlvbl9lbmRwb2ludFwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChhcy5yZXZvY2F0aW9uX2VuZHBvaW50KTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLmRlbGV0ZSgnYWNjZXB0Jyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBSZXZvY2F0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBib2R5IGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnRyb3NwZWN0aW9uUmVxdWVzdChhcywgY2xpZW50LCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcy5pbnRyb3NwZWN0aW9uX2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmludHJvc3BlY3Rpb25fZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMuaW50cm9zcGVjdGlvbl9lbmRwb2ludCk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaWYgKG9wdGlvbnM/LnJlcXVlc3RKd3RSZXNwb25zZSA/PyBjbGllbnQuaW50cm9zcGVjdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vdG9rZW4taW50cm9zcGVjdGlvbitqd3QnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBJbnRyb3NwZWN0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGxldCBqc29uO1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi90b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpIHtcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChhd2FpdCByZXNwb25zZS50ZXh0KCksIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaW50cm9zcGVjdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICd0b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnaWF0JywgJ2lzcyddKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgICAgICBqc29uID0gY2xhaW1zLnRva2VuX2ludHJvc3BlY3Rpb247XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgXCJ0b2tlbl9pbnRyb3NwZWN0aW9uXCIgY2xhaW0gbXVzdCBiZSBhIEpTT04gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24uYWN0aXZlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJhY3RpdmVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGp3a3NSZXF1ZXN0KGFzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGlmICh0eXBlb2YgYXMuandrc191cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMuandrc191cmlcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMuandrc191cmkpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBoZWFkZXJzLmFwcGVuZCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3ay1zZXQranNvbicpO1xuICAgIHJldHVybiBmZXRjaCh1cmwuaHJlZiwge1xuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NKd2tzUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gSlNPTiBXZWIgS2V5IFNldCByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5rZXlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImtleXNcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkucHJvdG90eXBlLmV2ZXJ5LmNhbGwoanNvbi5rZXlzLCBpc0pzb25PYmplY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwia2V5c1wiIHByb3BlcnR5IG1lbWJlcnMgbXVzdCBiZSBKV0sgZm9ybWF0dGVkIG9iamVjdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAzOTkgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25PYmplY3QoanNvbikgJiYgdHlwZW9mIGpzb24uZXJyb3IgPT09ICdzdHJpbmcnICYmIGpzb24uZXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uZXJyb3JfZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5lcnJvcl9kZXNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc29uLmVycm9yX3VyaSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLmVycm9yX3VyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXJyb3JfdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbi5hbGdzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uYWxncyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uYWxncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uc2NvcGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5zY29wZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY2hlY2tTdXBwb3J0ZWRKd3NBbGcoYWxnKSB7XG4gICAgaWYgKCFTVVBQT1JURURfSldTX0FMR1MuaW5jbHVkZXMoYWxnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldTIFwiYWxnXCIgaWRlbnRpZmllcicpO1xuICAgIH1cbiAgICByZXR1cm4gYWxnO1xufVxuZnVuY3Rpb24gY2hlY2tSc2FLZXlBbGdvcml0aG0oYWxnb3JpdGhtKSB7XG4gICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCAhPT0gJ251bWJlcicgfHwgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPCAyMDQ4KSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoYCR7YWxnb3JpdGhtLm5hbWV9IG1vZHVsdXNMZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAyMDQ4IGJpdHNgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlY2RzYUhhc2hOYW1lKG5hbWVkQ3VydmUpIHtcbiAgICBzd2l0Y2ggKG5hbWVkQ3VydmUpIHtcbiAgICAgICAgY2FzZSAnUC0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtMjU2JztcbiAgICAgICAgY2FzZSAnUC0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9TdWJ0bGUoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnRUNEU0EnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXkuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgICAgICAgaGFzaDogZWNkc2FIYXNoTmFtZShrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6IHtcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LmFsZ29yaXRobS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FsdExlbmd0aDogcGFyc2VJbnQoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUuc2xpY2UoLTMpLCAxMCkgPj4gMyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xuICAgICAgICAgICAgcmV0dXJuIGtleS5hbGdvcml0aG0ubmFtZTtcbiAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgICAgIHJldHVybiBrZXkuYWxnb3JpdGhtLm5hbWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG59XG5jb25zdCBub1NpZ25hdHVyZUNoZWNrID0gU3ltYm9sKCk7XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUp3dChqd3MsIGNoZWNrQWxnLCBnZXRLZXksIGNsb2NrU2tldywgY2xvY2tUb2xlcmFuY2UpIHtcbiAgICBjb25zdCB7IDA6IHByb3RlY3RlZEhlYWRlciwgMTogcGF5bG9hZCwgMjogZW5jb2RlZFNpZ25hdHVyZSwgbGVuZ3RoIH0gPSBqd3Muc3BsaXQoJy4nKTtcbiAgICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdKV0Ugc3RydWN0dXJlIEpXVHMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdJbnZhbGlkIEpXVCcpO1xuICAgIH1cbiAgICBsZXQgaGVhZGVyO1xuICAgIHRyeSB7XG4gICAgICAgIGhlYWRlciA9IEpTT04ucGFyc2UoYnVmKGI2NHUocHJvdGVjdGVkSGVhZGVyKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIEpXVCBIZWFkZXIgYm9keSBhcyBiYXNlNjR1cmwgZW5jb2RlZCBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoaGVhZGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgSGVhZGVyIG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNoZWNrQWxnKGhlYWRlcik7XG4gICAgaWYgKGhlYWRlci5jcml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJjcml0XCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGVuY29kZWRTaWduYXR1cmUpO1xuICAgIGlmIChnZXRLZXkgIT09IG5vU2lnbmF0dXJlQ2hlY2spIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0S2V5KGhlYWRlcik7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYCR7cHJvdGVjdGVkSGVhZGVyfS4ke3BheWxvYWR9YDtcbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShrZXlUb1N1YnRsZShrZXkpLCBrZXksIHNpZ25hdHVyZSwgYnVmKGlucHV0KSk7XG4gICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjbGFpbXM7XG4gICAgdHJ5IHtcbiAgICAgICAgY2xhaW1zID0gSlNPTi5wYXJzZShidWYoYjY0dShwYXlsb2FkKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIEpXVCBQYXlsb2FkIGJvZHkgYXMgYmFzZTY0dXJsIGVuY29kZWQgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIFBheWxvYWQgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBjbG9ja1NrZXc7XG4gICAgaWYgKGNsYWltcy5leHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5leHAgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImV4cFwiIChleHBpcmF0aW9uIHRpbWUpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLmV4cCA8PSBub3cgLSBjbG9ja1RvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSB2YWx1ZSwgdGltZXN0YW1wIGlzIDw9IG5vdygpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5pYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5pYXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlhdFwiIChpc3N1ZWQgYXQpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmlzcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaXNzXCIgKGlzc3VlcikgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMubmJmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMubmJmICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMubmJmID4gbm93ICsgY2xvY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIHZhbHVlLCB0aW1lc3RhbXAgaXMgPiBub3coKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuYXVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuYXVkICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBoZWFkZXIsIGNsYWltcywgc2lnbmF0dXJlIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgZXhwZWN0ZWRTdGF0ZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGlmICghKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBvciBVUkwnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Jlc3BvbnNlJyk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGEgSkFSTSByZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFzLmp3a3NfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmp3a3NfdXJpXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QocmVzcG9uc2UsIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmF1dGhvcml6YXRpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuYXV0aG9yaXphdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkuYmluZCh1bmRlZmluZWQsIGFzLCBvcHRpb25zKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2V4cCcsICdpc3MnXSkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNsYWltcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYga2V5ICE9PSAnYXVkJykge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzdWx0LCBleHBlY3RlZFN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbmluZ0FsZ29yaXRobShjbGllbnQsIGlzc3VlciwgaGVhZGVyKSB7XG4gICAgaWYgKGNsaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChoZWFkZXIuYWxnICE9PSBjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXNzdWVyKSkge1xuICAgICAgICBpZiAoIWlzc3Vlci5pbmNsdWRlcyhoZWFkZXIuYWxnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gJ1JTMjU2Jykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgbmFtZSkge1xuICAgIGNvbnN0IHsgMDogdmFsdWUsIGxlbmd0aCB9ID0gcGFyYW1ldGVycy5nZXRBbGwobmFtZSk7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRShgXCIke25hbWV9XCIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgb25seSBvbmNlYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCBza2lwU3RhdGVDaGVjayA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGV4cGVjdE5vU3RhdGUgPSBTeW1ib2woKTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMsIG9yIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdyZXNwb25zZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicGFyYW1ldGVyc1wiIGNvbnRhaW5zIGEgSkFSTSByZXNwb25zZSwgdXNlIHZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKCkgaW5zdGVhZCBvZiB2YWxpZGF0ZUF1dGhSZXNwb25zZSgpJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzcyA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaXNzJyk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3N0YXRlJyk7XG4gICAgaWYgKCFpc3MgJiYgYXMuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdyZXNwb25zZSBwYXJhbWV0ZXIgXCJpc3NcIiAoaXNzdWVyKSBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmIChpc3MgJiYgaXNzICE9PSBhcy5pc3N1ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcImlzc1wiIChpc3N1ZXIpIHJlc3BvbnNlIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV4cGVjdGVkU3RhdGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgZXhwZWN0Tm9TdGF0ZTpcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIGVuY291bnRlcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBza2lwU3RhdGVDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZFN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wiZXhwZWN0ZWRTdGF0ZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3Jlc3BvbnNlIHBhcmFtZXRlciBcInN0YXRlXCIgbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcicpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBlcnJvcl9kZXNjcmlwdGlvbjogZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcl9kZXNjcmlwdGlvbicpLFxuICAgICAgICAgICAgZXJyb3JfdXJpOiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2Vycm9yX3VyaScpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpZF90b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaWRfdG9rZW4nKTtcbiAgICBjb25zdCB0b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAndG9rZW4nKTtcbiAgICBpZiAoaWRfdG9rZW4gIT09IHVuZGVmaW5lZCB8fCB0b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdpbXBsaWNpdCBhbmQgaHlicmlkIGZsb3dzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBicmFuZChuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpKTtcbn1cbmZ1bmN0aW9uIGFsZ1RvU3VidGxlKGFsZywgY3J2KSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUFMyNTYnOlxuICAgICAgICBjYXNlICdQUzM4NCc6XG4gICAgICAgIGNhc2UgJ1BTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdSU0EtUFNTJywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgIGNhc2UgJ1JTMzg0JzpcbiAgICAgICAgY2FzZSAnUlM1MTInOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgIGNhc2UgJ0VTMzg0JzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6IGBQLSR7YWxnLnNsaWNlKC0zKX1gIH07XG4gICAgICAgIGNhc2UgJ0VTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6ICdQLTUyMScgfTtcbiAgICAgICAgY2FzZSAnRWREU0EnOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNydikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNydjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEp3ayhhbGcsIGp3aykge1xuICAgIGNvbnN0IHsgZXh0LCBrZXlfb3BzLCB1c2UsIC4uLmtleSB9ID0gandrO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywga2V5LCBhbGdUb1N1YnRsZShhbGcsIGp3ay5jcnYpLCB0cnVlLCBbJ3ZlcmlmeSddKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXZpY2VBdXRob3JpemF0aW9uUmVxdWVzdChhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICh0eXBlb2YgYXMuZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMuZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMuZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gRGV2aWNlIEF1dGhvcml6YXRpb24gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmRldmljZV9jb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImRldmljZV9jb2RlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnVzZXJfY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ1c2VyX2NvZGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24udmVyaWZpY2F0aW9uX3VyaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ2ZXJpZmljYXRpb25fdXJpXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInIHx8IGpzb24uZXhwaXJlc19pbiA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiZXhwaXJlc19pblwiIHByb3BlcnR5IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKGpzb24udmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF2YWxpZGF0ZVN0cmluZyhqc29uLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChqc29uLmludGVydmFsICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBqc29uLmludGVydmFsICE9PSAnbnVtYmVyJyB8fCBqc29uLmludGVydmFsIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaW50ZXJ2YWxcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldmljZUNvZGVHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgZGV2aWNlQ29kZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGRldmljZUNvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGV2aWNlQ29kZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnZGV2aWNlX2NvZGUnLCBkZXZpY2VDb2RlKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmRldmljZV9jb2RlJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpcihhbGcsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFsZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbGdcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBhbGdvcml0aG0gPSBhbGdUb1N1YnRsZShhbGcsIGFsZyA9PT0gJ0VkRFNBJyA/IG9wdGlvbnM/LmNydiA/PyAnRWQyNTUxOScgOiB1bmRlZmluZWQpO1xuICAgIGlmIChhbGcuc3RhcnRzV2l0aCgnUFMnKSB8fCBhbGcuc3RhcnRzV2l0aCgnUlMnKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGFsZ29yaXRobSwge1xuICAgICAgICAgICAgbW9kdWx1c0xlbmd0aDogb3B0aW9ucz8ubW9kdWx1c0xlbmd0aCA/PyAyMDQ4LFxuICAgICAgICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAwLCAweDAxXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBvcHRpb25zPy5leHRyYWN0YWJsZSA/PyBmYWxzZSwgWydzaWduJywgJ3ZlcmlmeSddKSk7XG59XG4iXSwibmFtZXMiOlsiVVNFUl9BR0VOVCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInN0YXJ0c1dpdGgiLCJOQU1FIiwiVkVSU0lPTiIsImNsb2NrU2tldyIsIlN5bWJvbCIsImNsb2NrVG9sZXJhbmNlIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmIiwiaW5wdXQiLCJlbmNvZGUiLCJkZWNvZGUiLCJDSFVOS19TSVpFIiwiZW5jb2RlQmFzZTY0VXJsIiwiQXJyYXlCdWZmZXIiLCJVaW50OEFycmF5IiwiYXJyIiwiaSIsImJ5dGVMZW5ndGgiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJzdWJhcnJheSIsImJ0b2EiLCJqb2luIiwicmVwbGFjZSIsImRlY29kZUJhc2U2NFVybCIsImJpbmFyeSIsImF0b2IiLCJieXRlcyIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjYXVzZSIsIk9QRSIsImI2NHUiLCJMUlUiLCJjb25zdHJ1Y3RvciIsIm1heFNpemUiLCJjYWNoZSIsIk1hcCIsIl9jYWNoZSIsImdldCIsImtleSIsInYiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJoYXMiLCJzZXQiLCJ2YWx1ZSIsImRlbGV0ZSIsInNpemUiLCJVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiT3BlcmF0aW9uUHJvY2Vzc2luZ0Vycm9yIiwib3B0aW9ucyIsImRwb3BOb25jZXMiLCJpc0NyeXB0b0tleSIsIkNyeXB0b0tleSIsImlzUHJpdmF0ZUtleSIsInR5cGUiLCJpc1B1YmxpY0tleSIsIlNVUFBPUlRFRF9KV1NfQUxHUyIsInByb2Nlc3NEcG9wTm9uY2UiLCJyZXNwb25zZSIsInVybCIsIlVSTCIsImhlYWRlcnMiLCJvcmlnaW4iLCJub3JtYWxpemVUeXAiLCJ0b0xvd2VyQ2FzZSIsImlzSnNvbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInByZXBhcmVIZWFkZXJzIiwiSGVhZGVycyIsIlR5cGVFcnJvciIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwiZGlzY292ZXJ5UmVxdWVzdCIsImlzc3VlcklkZW50aWZpZXIiLCJwcm90b2NvbCIsImhyZWYiLCJhbGdvcml0aG0iLCJwYXRobmFtZSIsImZldGNoIiwibWV0aG9kIiwicmVkaXJlY3QiLCJ0aGVuIiwidmFsaWRhdGVTdHJpbmciLCJwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UiLCJleHBlY3RlZElzc3VlcklkZW50aWZpZXIiLCJSZXNwb25zZSIsInN0YXR1cyIsImFzc2VydFJlYWRhYmxlUmVzcG9uc2UiLCJqc29uIiwiaXNzdWVyIiwicmFuZG9tQnl0ZXMiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJnZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllciIsImdlbmVyYXRlUmFuZG9tU3RhdGUiLCJnZW5lcmF0ZVJhbmRvbU5vbmNlIiwiY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UiLCJjb2RlVmVyaWZpZXIiLCJzdWJ0bGUiLCJkaWdlc3QiLCJnZXRLZXlBbmRLaWQiLCJraWQiLCJmb3JtVXJsRW5jb2RlIiwidG9rZW4iLCJlbmNvZGVVUklDb21wb25lbnQiLCJjbGllbnRTZWNyZXRCYXNpYyIsImNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImNyZWRlbnRpYWxzIiwicHNBbGciLCJoYXNoIiwicnNBbGciLCJlc0FsZyIsIm5hbWVkQ3VydmUiLCJrZXlUb0p3cyIsImdldENsb2NrU2tldyIsImNsaWVudCIsIk51bWJlciIsImlzRmluaXRlIiwiZ2V0Q2xvY2tUb2xlcmFuY2UiLCJ0b2xlcmFuY2UiLCJNYXRoIiwic2lnbiIsImVwb2NoVGltZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImNsaWVudEFzc2VydGlvbiIsImFzIiwianRpIiwiYXVkIiwidG9rZW5fZW5kcG9pbnQiLCJleHAiLCJpYXQiLCJuYmYiLCJpc3MiLCJjbGllbnRfaWQiLCJzdWIiLCJwcml2YXRlS2V5Snd0Iiwiand0IiwiYWxnIiwiYXNzZXJ0QXMiLCJhc3NlcnRDbGllbnQiLCJhc3NlcnRDbGllbnRTZWNyZXQiLCJhc3NlcnROb0NsaWVudFByaXZhdGVLZXkiLCJjbGllbnRBdXRoTWV0aG9kIiwiY2xpZW50UHJpdmF0ZUtleSIsImFzc2VydE5vQ2xpZW50U2VjcmV0IiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJib2R5IiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QiLCJjbGllbnRfc2VjcmV0IiwiaGVhZGVyIiwiY2xhaW1zU2V0IiwidXNhZ2VzIiwiaW5jbHVkZXMiLCJKU09OIiwic3RyaW5naWZ5Iiwic2lnbmF0dXJlIiwia2V5VG9TdWJ0bGUiLCJpc3N1ZVJlcXVlc3RPYmplY3QiLCJwYXJhbWV0ZXJzIiwicHJpdmF0ZUtleSIsIlVSTFNlYXJjaFBhcmFtcyIsImNsYWltcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsInJlc291cmNlIiwiZ2V0QWxsIiwicGFyc2UiLCJ0eXAiLCJkcG9wUHJvb2ZKd3QiLCJodG0iLCJhY2Nlc3NUb2tlbiIsInB1YmxpY0tleSIsIm5vbmNlIiwiZXh0cmFjdGFibGUiLCJwcm9vZiIsImp3ayIsInB1YmxpY0p3ayIsImh0dSIsImF0aCIsImp3a0NhY2hlIiwiV2Vha01hcCIsImt0eSIsImUiLCJuIiwieCIsInkiLCJjcnYiLCJleHBvcnRLZXkiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsInB1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQiLCJEUG9QIiwiYXV0aGVudGljYXRlZFJlcXVlc3QiLCJpc09BdXRoMkVycm9yIiwiZXJyb3IiLCJ1bnF1b3RlIiwic2xpY2UiLCJTUExJVF9SRUdFWFAiLCJTQ0hFTUVTX1JFR0VYUCIsInd3d0F1dGgiLCJzY2hlbWUiLCJwYXJhbXMiLCJzcGxpdCIsImlkeCIsInBhcnNlV3d3QXV0aGVudGljYXRlQ2hhbGxlbmdlcyIsInJlc3VsdCIsImluZGV4IiwibWF0Y2hBbGwiLCJjaGFsbGVuZ2VzIiwibWFwIiwiaW5kZXhPZiIsIm90aGVycyIsIm5leHQiLCJwcm9jZXNzUHVzaGVkQXV0aG9yaXphdGlvblJlc3BvbnNlIiwiZXJyIiwiaGFuZGxlT0F1dGhCb2R5RXJyb3IiLCJyZXF1ZXN0X3VyaSIsImV4cGlyZXNfaW4iLCJwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QiLCJ1c2VySW5mb1JlcXVlc3QiLCJ1c2VyaW5mb19lbmRwb2ludCIsInVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhcHBlbmQiLCJqd2tzQ2FjaGUiLCJnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaSIsImNoZWNrU3VwcG9ydGVkSndzQWxnIiwiandrcyIsImFnZSIsImp3a3NSZXF1ZXN0IiwicHJvY2Vzc0p3a3NSZXNwb25zZSIsImNhbmRpZGF0ZXMiLCJrZXlzIiwiZmlsdGVyIiwidXNlIiwia2V5X29wcyIsImltcG9ydEp3ayIsInNraXBTdWJqZWN0Q2hlY2siLCJnZXRDb250ZW50VHlwZSIsInByb2Nlc3NVc2VySW5mb1Jlc3BvbnNlIiwiZXhwZWN0ZWRTdWJqZWN0IiwidmFsaWRhdGVKd3QiLCJ0ZXh0IiwiY2hlY2tTaWduaW5nQWxnb3JpdGhtIiwiYmluZCIsInVzZXJpbmZvX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJub1NpZ25hdHVyZUNoZWNrIiwidmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlIiwidmFsaWRhdGVPcHRpb25hbElzc3VlciIsInRva2VuRW5kcG9pbnRSZXF1ZXN0IiwiZ3JhbnRUeXBlIiwicmVmcmVzaFRva2VuR3JhbnRSZXF1ZXN0IiwicmVmcmVzaFRva2VuIiwiYWRkaXRpb25hbFBhcmFtZXRlcnMiLCJpZFRva2VuQ2xhaW1zIiwiZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyIsInJlZiIsImlkX3Rva2VuIiwicHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlIiwiaWdub3JlSWRUb2tlbiIsImlnbm9yZVJlZnJlc2hUb2tlbiIsImFjY2Vzc190b2tlbiIsInRva2VuX3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwic2NvcGUiLCJpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsInZhbGlkYXRlUHJlc2VuY2UiLCJ2YWxpZGF0ZUlzc3VlciIsInZhbGlkYXRlQXVkaWVuY2UiLCJhenAiLCJyZXF1aXJlX2F1dGhfdGltZSIsImF1dGhfdGltZSIsInByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZSIsImV4cGVjdGVkIiwiYnJhbmRlZCIsIldlYWtTZXQiLCJicmFuZCIsInNlYXJjaFBhcmFtcyIsImFkZCIsImF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0IiwiY2FsbGJhY2tQYXJhbWV0ZXJzIiwicmVkaXJlY3RVcmkiLCJjb2RlIiwiZ2V0VVJMU2VhcmNoUGFyYW1ldGVyIiwiY2xhaW1OYW1lcyIsInJlcXVpcmVkIiwiY2xhaW0iLCJleHBlY3ROb05vbmNlIiwic2tpcEF1dGhUaW1lQ2hlY2siLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZSIsImV4cGVjdGVkTm9uY2UiLCJtYXhBZ2UiLCJkZWZhdWx0X21heF9hZ2UiLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPQXV0aDJSZXNwb25zZSIsImNoZWNrSnd0VHlwZSIsImNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0IiwicHJvY2Vzc0NsaWVudENyZWRlbnRpYWxzUmVzcG9uc2UiLCJyZXZvY2F0aW9uUmVxdWVzdCIsInJldm9jYXRpb25fZW5kcG9pbnQiLCJwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlIiwiYm9keVVzZWQiLCJpbnRyb3NwZWN0aW9uUmVxdWVzdCIsImludHJvc3BlY3Rpb25fZW5kcG9pbnQiLCJyZXF1ZXN0Snd0UmVzcG9uc2UiLCJpbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJwcm9jZXNzSW50cm9zcGVjdGlvblJlc3BvbnNlIiwiaW50cm9zcGVjdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidG9rZW5faW50cm9zcGVjdGlvbiIsImFjdGl2ZSIsImp3a3NfdXJpIiwicHJvdG90eXBlIiwiZXZlcnkiLCJjYWxsIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvcl91cmkiLCJhbGdzIiwiY2hlY2tSc2FLZXlBbGdvcml0aG0iLCJtb2R1bHVzTGVuZ3RoIiwiZWNkc2FIYXNoTmFtZSIsInNhbHRMZW5ndGgiLCJwYXJzZUludCIsImp3cyIsImNoZWNrQWxnIiwiZ2V0S2V5IiwicHJvdGVjdGVkSGVhZGVyIiwicGF5bG9hZCIsImVuY29kZWRTaWduYXR1cmUiLCJjcml0IiwidmVyaWZpZWQiLCJ2ZXJpZnkiLCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSIsImV4cGVjdGVkU3RhdGUiLCJhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhdXRob3JpemF0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSIsInNraXBTdGF0ZUNoZWNrIiwiZXhwZWN0Tm9TdGF0ZSIsInN0YXRlIiwiYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCIsImFsZ1RvU3VidGxlIiwiZXh0IiwiaW1wb3J0S2V5IiwiZGV2aWNlQXV0aG9yaXphdGlvblJlcXVlc3QiLCJkZXZpY2VfYXV0aG9yaXphdGlvbl9lbmRwb2ludCIsInByb2Nlc3NEZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UiLCJkZXZpY2VfY29kZSIsInVzZXJfY29kZSIsInZlcmlmaWNhdGlvbl91cmkiLCJ2ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlIiwiaW50ZXJ2YWwiLCJkZXZpY2VDb2RlR3JhbnRSZXF1ZXN0IiwiZGV2aWNlQ29kZSIsInByb2Nlc3NEZXZpY2VDb2RlUmVzcG9uc2UiLCJnZW5lcmF0ZUtleVBhaXIiLCJhc3NpZ24iLCJwdWJsaWNFeHBvbmVudCIsImdlbmVyYXRlS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/oauth4webapi/build/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isOAuth2Error: () => (/* binding */ isOAuth2Error),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   parseWwwAuthenticateChallenges: () => (/* binding */ parseWwwAuthenticateChallenges),\n/* harmony export */   processAuthorizationCodeOAuth2Response: () => (/* binding */ processAuthorizationCodeOAuth2Response),\n/* harmony export */   processAuthorizationCodeOpenIDResponse: () => (/* binding */ processAuthorizationCodeOpenIDResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v2.4.0\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    } catch (cause) {\n        throw new OPE(\"The input to be decoded is not correctly encoded.\", {\n            cause\n        });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize){\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if (v = this._cache.get(key)) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        } else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message){\n        super(message ?? \"operation not supported\");\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === \"private\";\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === \"public\";\n}\nconst SUPPORTED_JWS_ALGS = [\n    \"PS256\",\n    \"ES256\",\n    \"RS256\",\n    \"PS384\",\n    \"ES384\",\n    \"RS384\",\n    \"PS512\",\n    \"ES512\",\n    \"RS512\",\n    \"EdDSA\"\n];\nfunction processDpopNonce(response) {\n    const url = new URL(response.url);\n    if (response.headers.has(\"dpop-nonce\")) {\n        dpopNonces.set(url.origin, response.headers.get(\"dpop-nonce\"));\n    }\n    return response;\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (input !== undefined && !(input instanceof Headers)) {\n        throw new TypeError('\"options.headers\" must be an instance of Headers');\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has(\"dpop\")) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === \"function\") {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== \"https:\" && issuerIdentifier.protocol !== \"http:\") {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch(options?.algorithm){\n        case undefined:\n        case \"oidc\":\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace(\"//\", \"/\");\n            break;\n        case \"oauth2\":\n            if (url.pathname === \"/\") {\n                url.pathname = `.well-known/oauth-authorization-server`;\n            } else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace(\"//\", \"/\");\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return fetch(url.href, {\n        headers,\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === \"string\" && input.length !== 0;\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, \"+\");\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\");\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\");\n    }\n}\nfunction getClockSkew(client) {\n    if (Number.isFinite(client[clockSkew])) {\n        return client[clockSkew];\n    }\n    return 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client[clockTolerance];\n    if (Number.isFinite(tolerance) && Math.sign(tolerance) !== -1) {\n        return tolerance;\n    }\n    return 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [\n            as.issuer,\n            as.token_endpoint\n        ],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nasync function privateKeyJwt(as, client, key, kid) {\n    return jwt({\n        alg: keyToJws(key),\n        kid\n    }, clientAssertion(as, client), key);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete(\"client_secret\");\n    body.delete(\"client_assertion_type\");\n    body.delete(\"client_assertion\");\n    switch(client.token_endpoint_auth_method){\n        case undefined:\n        case \"client_secret_basic\":\n            {\n                assertNoClientPrivateKey(\"client_secret_basic\", clientPrivateKey);\n                headers.set(\"authorization\", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n                break;\n            }\n        case \"client_secret_post\":\n            {\n                assertNoClientPrivateKey(\"client_secret_post\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_secret\", assertClientSecret(client.client_secret));\n                break;\n            }\n        case \"private_key_jwt\":\n            {\n                assertNoClientSecret(\"private_key_jwt\", client.client_secret);\n                if (clientPrivateKey === undefined) {\n                    throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n                }\n                const { key, kid } = getKeyAndKid(clientPrivateKey);\n                if (!isPrivateKey(key)) {\n                    throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n                }\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                body.set(\"client_assertion\", await privateKeyJwt(as, client, key, kid));\n                break;\n            }\n        case \"none\":\n            {\n                assertNoClientSecret(\"none\", client.client_secret);\n                assertNoClientPrivateKey(\"none\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                break;\n            }\n        default:\n            throw new UnsupportedOperationError(\"unsupported client token_endpoint_auth_method\");\n    }\n}\nasync function jwt(header, claimsSet, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(claimsSet)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    if (parameters.has(\"claims\")) {\n        const value = parameters.get(\"claims\");\n        if (value === \"[object Object]\") {\n            throw new OPE('\"claims\" parameter must be passed as a UTF-8 encoded JSON');\n        }\n        try {\n            claims.claims = JSON.parse(value);\n        } catch (cause) {\n            throw new OPE('failed to parse the \"claims\" parameter as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(claims.claims)) {\n            throw new OPE('\"claims\" parameter must be a top level object');\n        }\n    }\n    return jwt({\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    }, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const proof = await jwt({\n        alg: keyToJws(privateKey),\n        typ: \"dpop+jwt\",\n        jwk: await publicJwk(publicKey)\n    }, {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n    }, privateKey);\n    headers.set(\"dpop\", proof);\n}\nlet jwkCache;\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    if (jwkCache.has(key)) {\n        return jwkCache.get(key);\n    }\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv\n    };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.pushed_authorization_request_endpoint !== \"string\") {\n        throw new TypeError('\"as.pushed_authorization_request_endpoint\" must be a string');\n    }\n    const url = new URL(as.pushed_authorization_request_endpoint);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nfunction isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== \"object\" || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return {\n            scheme: scheme.toLowerCase(),\n            parameters: {}\n        };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, \"\");\n    const parameters = {};\n    for(let i = 1; i < arr.length; i += 2){\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while(arr[idx].slice(-1) !== '\"' && ++i < arr.length){\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, \"\").toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters\n    };\n}\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (!response.headers.has(\"www-authenticate\")) {\n        return undefined;\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)){\n        result.push([\n            scheme,\n            index\n        ]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others)=>{\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        } else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set(\"authorization\", `Bearer ${accessToken}`);\n    } else {\n        await dpopProofJwt(headers, options.DPoP, url, \"GET\", getClockSkew({\n            [clockSkew]: options?.clockSkew\n        }), accessToken);\n        headers.set(\"authorization\", `DPoP ${accessToken}`);\n    }\n    return fetch(url.href, {\n        body,\n        headers,\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.userinfo_endpoint !== \"string\") {\n        throw new TypeError('\"as.userinfo_endpoint\" must be a string');\n    }\n    const url = new URL(as.userinfo_endpoint);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return protectedResourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        clockSkew: getClockSkew(client)\n    });\n}\nlet jwksCache;\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    let jwks;\n    let age;\n    jwksCache || (jwksCache = new WeakMap());\n    if (jwksCache.has(as)) {\n        ;\n        ({ jwks, age } = jwksCache.get(as));\n        if (age >= 300) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        jwksCache.set(as, {\n            jwks,\n            iat: epochTime(),\n            get age () {\n                return epochTime() - this.iat;\n            }\n        });\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"EdDSA\" && !(jwk.crv === \"Ed25519\" || jwk.crv === \"Ed448\"):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE(\"error when selecting a JWT verification key, no applicable keys found\");\n    } else if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw new OPE(\"jwks_uri must only contain public keys\");\n    }\n    return key;\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as.issuer));\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE(\"JWT UserInfo Response expected\");\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return fetch(url.href, {\n        body,\n        headers,\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    if (typeof as.token_endpoint !== \"string\") {\n        throw new TypeError('\"as.token_endpoint\" must be a string');\n    }\n    const url = new URL(as.token_endpoint);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, parameters, headers, options);\n}\nasync function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims;\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\");\n    }\n    if (json.expires_in !== undefined && (typeof json.expires_in !== \"number\" || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken && json.refresh_token !== undefined && !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n                \"aud\",\n                \"exp\",\n                \"iat\",\n                \"iss\",\n                \"sub\"\n            ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n                throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n            }\n            if (client.require_auth_time && typeof claims.auth_time !== \"number\") {\n                throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n            }\n            idTokenClaims.set(json, claims);\n        }\n    }\n    return json;\n}\nasync function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    } else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nasync function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code_verifier\", codeVerifier);\n    parameters.set(\"code\", code);\n    return tokenEndpointRequest(as, client, \"authorization_code\", parameters, options);\n}\nconst claimNames = {\n    aud: \"audience\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    sub: \"subject\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${claimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    switch(expectedNonce){\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === \"string\" && result.id_token.length) {\n            throw new OPE(\"Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing\");\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nasync function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    if (typeof as.revocation_endpoint !== \"string\") {\n        throw new TypeError('\"as.revocation_endpoint\" must be a string');\n    }\n    const url = new URL(as.revocation_endpoint);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nasync function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    if (typeof as.introspection_endpoint !== \"string\") {\n        throw new TypeError('\"as.introspection_endpoint\" must be a string');\n    }\n    const url = new URL(as.introspection_endpoint);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    } else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const url = new URL(as.jwks_uri);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return fetch(url.href, {\n        headers,\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== \"string\") {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== \"string\") {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== \"string\") {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== \"string\") {\n                    delete json.scope;\n                }\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch(namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key.algorithm);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case \"Ed448\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance) {\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\");\n    if (length === 5) {\n        throw new UnsupportedOperationError(\"JWE structure JWTs are not supported\");\n    }\n    if (length !== 3) {\n        throw new OPE(\"Invalid JWT\");\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Header body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE(\"JWT Header must be a top level object\");\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    if (getKey !== noSignatureCheck) {\n        const key = await getKey(header);\n        const input = `${protectedHeader}.${payload}`;\n        const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n        if (!verified) {\n            throw new OPE(\"JWT signature verification failed\");\n        }\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE(\"JWT Payload must be a top level object\");\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return {\n        header,\n        claims,\n        signature\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== \"RS256\") {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, \"error_description\"),\n            error_uri: getURLSearchParameter(parameters, \"error_uri\")\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        return crv;\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg, jwk.crv), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.device_authorization_endpoint !== \"string\") {\n        throw new TypeError('\"as.device_authorization_endpoint\" must be a string');\n    }\n    const url = new URL(as.device_authorization_endpoint);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined && !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== \"number\" || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nasync function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === \"EdDSA\" ? options?.crv ?? \"Ed25519\" : undefined);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBO0FBQ0osSUFBSSxPQUFPQyxjQUFjLGVBQWUsQ0FBQ0EsVUFBVUMsU0FBUyxFQUFFQyxhQUFhLGlCQUFpQjtJQUN4RixNQUFNQyxPQUFPO0lBQ2IsTUFBTUMsVUFBVTtJQUNoQkwsYUFBYSxDQUFDLEVBQUVJLEtBQUssQ0FBQyxFQUFFQyxRQUFRLENBQUM7QUFDckM7QUFDTyxNQUFNQyxZQUFZQyxTQUFTO0FBQzNCLE1BQU1DLGlCQUFpQkQsU0FBUztBQUN2QyxNQUFNRSxVQUFVLElBQUlDO0FBQ3BCLE1BQU1DLFVBQVUsSUFBSUM7QUFDcEIsU0FBU0MsSUFBSUMsS0FBSztJQUNkLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzNCLE9BQU9MLFFBQVFNLE1BQU0sQ0FBQ0Q7SUFDMUI7SUFDQSxPQUFPSCxRQUFRSyxNQUFNLENBQUNGO0FBQzFCO0FBQ0EsTUFBTUcsYUFBYTtBQUNuQixTQUFTQyxnQkFBZ0JKLEtBQUs7SUFDMUIsSUFBSUEsaUJBQWlCSyxhQUFhO1FBQzlCTCxRQUFRLElBQUlNLFdBQVdOO0lBQzNCO0lBQ0EsTUFBTU8sTUFBTSxFQUFFO0lBQ2QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLE1BQU1TLFVBQVUsRUFBRUQsS0FBS0wsV0FBWTtRQUNuREksSUFBSUcsSUFBSSxDQUFDQyxPQUFPQyxZQUFZLENBQUNDLEtBQUssQ0FBQyxNQUFNYixNQUFNYyxRQUFRLENBQUNOLEdBQUdBLElBQUlMO0lBQ25FO0lBQ0EsT0FBT1ksS0FBS1IsSUFBSVMsSUFBSSxDQUFDLEtBQUtDLE9BQU8sQ0FBQyxNQUFNLElBQUlBLE9BQU8sQ0FBQyxPQUFPLEtBQUtBLE9BQU8sQ0FBQyxPQUFPO0FBQ25GO0FBQ0EsU0FBU0MsZ0JBQWdCbEIsS0FBSztJQUMx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L2J1aWxkL2luZGV4LmpzPzNkNDEiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFVTRVJfQUdFTlQ7XG5pZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci51c2VyQWdlbnQ/LnN0YXJ0c1dpdGg/LignTW96aWxsYS81LjAgJykpIHtcbiAgICBjb25zdCBOQU1FID0gJ29hdXRoNHdlYmFwaSc7XG4gICAgY29uc3QgVkVSU0lPTiA9ICd2Mi40LjAnO1xuICAgIFVTRVJfQUdFTlQgPSBgJHtOQU1FfS8ke1ZFUlNJT059YDtcbn1cbmV4cG9ydCBjb25zdCBjbG9ja1NrZXcgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBjbG9ja1RvbGVyYW5jZSA9IFN5bWJvbCgpO1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gYnVmKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbn1cbmNvbnN0IENIVU5LX1NJWkUgPSAweDgwMDA7XG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRVcmwoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5ieXRlTGVuZ3RoOyBpICs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgYXJyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbnB1dC5zdWJhcnJheShpLCBpICsgQ0hVTktfU0laRSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYXJyLmpvaW4oJycpKS5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NFVybChpbnB1dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoaW5wdXQucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnVGhlIGlucHV0IHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLicsIHsgY2F1c2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYjY0dShpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVCYXNlNjRVcmwoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0VXJsKGlucHV0KTtcbn1cbmNsYXNzIExSVSB7XG4gICAgY29uc3RydWN0b3IobWF4U2l6ZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBsZXQgdiA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHYgPSB0aGlzLl9jYWNoZS5nZXQoa2V5KSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGtleSwgdik7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmhhcyhrZXkpIHx8IHRoaXMuX2NhY2hlLmhhcyhrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5jYWNoZTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ29wZXJhdGlvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/Lih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3BlcmF0aW9uUHJvY2Vzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/Lih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5jb25zdCBPUEUgPSBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3I7XG5jb25zdCBkcG9wTm9uY2VzID0gbmV3IExSVSgxMDApO1xuZnVuY3Rpb24gaXNDcnlwdG9LZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbnN0YW5jZW9mIENyeXB0b0tleTtcbn1cbmZ1bmN0aW9uIGlzUHJpdmF0ZUtleShrZXkpIHtcbiAgICByZXR1cm4gaXNDcnlwdG9LZXkoa2V5KSAmJiBrZXkudHlwZSA9PT0gJ3ByaXZhdGUnO1xufVxuZnVuY3Rpb24gaXNQdWJsaWNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGlzQ3J5cHRvS2V5KGtleSkgJiYga2V5LnR5cGUgPT09ICdwdWJsaWMnO1xufVxuY29uc3QgU1VQUE9SVEVEX0pXU19BTEdTID0gW1xuICAgICdQUzI1NicsXG4gICAgJ0VTMjU2JyxcbiAgICAnUlMyNTYnLFxuICAgICdQUzM4NCcsXG4gICAgJ0VTMzg0JyxcbiAgICAnUlMzODQnLFxuICAgICdQUzUxMicsXG4gICAgJ0VTNTEyJyxcbiAgICAnUlM1MTInLFxuICAgICdFZERTQScsXG5dO1xuZnVuY3Rpb24gcHJvY2Vzc0Rwb3BOb25jZShyZXNwb25zZSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKTtcbiAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5oYXMoJ2Rwb3Atbm9uY2UnKSkge1xuICAgICAgICBkcG9wTm9uY2VzLnNldCh1cmwub3JpZ2luLCByZXNwb25zZS5oZWFkZXJzLmdldCgnZHBvcC1ub25jZScpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVHlwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXmFwcGxpY2F0aW9uXFwvLywgJycpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVIZWFkZXJzKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ICE9PSB1bmRlZmluZWQgJiYgIShpbnB1dCBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5oZWFkZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBIZWFkZXJzJyk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dCk7XG4gICAgaWYgKFVTRVJfQUdFTlQgJiYgIWhlYWRlcnMuaGFzKCd1c2VyLWFnZW50JykpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ3VzZXItYWdlbnQnLCBVU0VSX0FHRU5UKTtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnMuaGFzKCdhdXRob3JpemF0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmhlYWRlcnNcIiBtdXN0IG5vdCBpbmNsdWRlIHRoZSBcImF1dGhvcml6YXRpb25cIiBoZWFkZXIgbmFtZScpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVycy5oYXMoJ2Rwb3AnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuaGVhZGVyc1wiIG11c3Qgbm90IGluY2x1ZGUgdGhlIFwiZHBvcFwiIGhlYWRlciBuYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gc2lnbmFsKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5zaWduYWxcIiBtdXN0IHJldHVybiBvciBiZSBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJ5UmVxdWVzdChpc3N1ZXJJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoaXNzdWVySWRlbnRpZmllciBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJpc3N1ZXJJZGVudGlmaWVyXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwnKTtcbiAgICB9XG4gICAgaWYgKGlzc3VlcklkZW50aWZpZXIucHJvdG9jb2wgIT09ICdodHRwczonICYmIGlzc3VlcklkZW50aWZpZXIucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJpc3N1ZXIucHJvdG9jb2xcIiBtdXN0IGJlIFwiaHR0cHM6XCIgb3IgXCJodHRwOlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaXNzdWVySWRlbnRpZmllci5ocmVmKTtcbiAgICBzd2l0Y2ggKG9wdGlvbnM/LmFsZ29yaXRobSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnb2lkYyc6XG4gICAgICAgICAgICB1cmwucGF0aG5hbWUgPSBgJHt1cmwucGF0aG5hbWV9Ly53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYC5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2F1dGgyJzpcbiAgICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlcmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwucGF0aG5hbWUgPSBgLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXIvJHt1cmwucGF0aG5hbWV9YC5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5hbGdvcml0aG1cIiBtdXN0IGJlIFwib2lkY1wiIChkZWZhdWx0KSwgb3IgXCJvYXV0aDJcIicpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIGZldGNoKHVybC5ocmVmLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgPyBzaWduYWwob3B0aW9ucy5zaWduYWwpIDogbnVsbCxcbiAgICB9KS50aGVuKHByb2Nlc3NEcG9wTm9uY2UpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBpbnB1dC5sZW5ndGggIT09IDA7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0Rpc2NvdmVyeVJlc3BvbnNlKGV4cGVjdGVkSXNzdWVySWRlbnRpZmllciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoIShleHBlY3RlZElzc3VlcklkZW50aWZpZXIgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXhwZWN0ZWRJc3N1ZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gQXV0aG9yaXphdGlvbiBTZXJ2ZXIgTWV0YWRhdGEgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmlzc3VlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpc3N1ZXJcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAobmV3IFVSTChqc29uLmlzc3VlcikuaHJlZiAhPT0gZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyLmhyZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpc3N1ZXJcIiBkb2VzIG5vdCBtYXRjaCBcImV4cGVjdGVkSXNzdWVyXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5mdW5jdGlvbiByYW5kb21CeXRlcygpIHtcbiAgICByZXR1cm4gYjY0dShjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tQ29kZVZlcmlmaWVyKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tU3RhdGUoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Ob25jZSgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVQS0NFQ29kZUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNvZGVWZXJpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjb2RlVmVyaWZpZXJcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGJ1Zihjb2RlVmVyaWZpZXIpKSk7XG59XG5mdW5jdGlvbiBnZXRLZXlBbmRLaWQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDcnlwdG9LZXkpIHtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBpbnB1dCB9O1xuICAgIH1cbiAgICBpZiAoIShpbnB1dD8ua2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5KSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChpbnB1dC5raWQgIT09IHVuZGVmaW5lZCAmJiAhdmFsaWRhdGVTdHJpbmcoaW5wdXQua2lkKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImtpZFwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB7IGtleTogaW5wdXQua2V5LCBraWQ6IGlucHV0LmtpZCB9O1xufVxuZnVuY3Rpb24gZm9ybVVybEVuY29kZSh0b2tlbikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodG9rZW4pLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuZnVuY3Rpb24gY2xpZW50U2VjcmV0QmFzaWMoY2xpZW50SWQsIGNsaWVudFNlY3JldCkge1xuICAgIGNvbnN0IHVzZXJuYW1lID0gZm9ybVVybEVuY29kZShjbGllbnRJZCk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBmb3JtVXJsRW5jb2RlKGNsaWVudFNlY3JldCk7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBidG9hKGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWApO1xuICAgIHJldHVybiBgQmFzaWMgJHtjcmVkZW50aWFsc31gO1xufVxuZnVuY3Rpb24gcHNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnUFMyNTYnO1xuICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnUFMzODQnO1xuICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgIHJldHVybiAnUFM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIFJzYUhhc2hlZEtleUFsZ29yaXRobSBoYXNoIG5hbWUnKTtcbiAgICB9XG59XG5mdW5jdGlvbiByc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdSUzI1Nic7XG4gICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdSUzM4NCc7XG4gICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgcmV0dXJuICdSUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgUnNhSGFzaGVkS2V5QWxnb3JpdGhtIGhhc2ggbmFtZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKSB7XG4gICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnRVMyNTYnO1xuICAgICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ0VTMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgRWNLZXlBbGdvcml0aG0gbmFtZWRDdXJ2ZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleVRvSndzKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1JTQS1QU1MnOlxuICAgICAgICAgICAgcmV0dXJuIHBzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgICAgICAgIHJldHVybiByc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdFQ0RTQSc6XG4gICAgICAgICAgICByZXR1cm4gZXNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgICAgIHJldHVybiAnRWREU0EnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIENyeXB0b0tleSBhbGdvcml0aG0gbmFtZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENsb2NrU2tldyhjbGllbnQpIHtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGNsaWVudFtjbG9ja1NrZXddKSkge1xuICAgICAgICByZXR1cm4gY2xpZW50W2Nsb2NrU2tld107XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSB7XG4gICAgY29uc3QgdG9sZXJhbmNlID0gY2xpZW50W2Nsb2NrVG9sZXJhbmNlXTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHRvbGVyYW5jZSkgJiYgTWF0aC5zaWduKHRvbGVyYW5jZSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0b2xlcmFuY2U7XG4gICAgfVxuICAgIHJldHVybiAzMDtcbn1cbmZ1bmN0aW9uIGVwb2NoVGltZSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG59XG5mdW5jdGlvbiBjbGllbnRBc3NlcnRpb24oYXMsIGNsaWVudCkge1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICBhdWQ6IFthcy5pc3N1ZXIsIGFzLnRva2VuX2VuZHBvaW50XSxcbiAgICAgICAgZXhwOiBub3cgKyA2MCxcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIG5iZjogbm93LFxuICAgICAgICBpc3M6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgICAgIHN1YjogY2xpZW50LmNsaWVudF9pZCxcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcHJpdmF0ZUtleUp3dChhcywgY2xpZW50LCBrZXksIGtpZCkge1xuICAgIHJldHVybiBqd3Qoe1xuICAgICAgICBhbGc6IGtleVRvSndzKGtleSksXG4gICAgICAgIGtpZCxcbiAgICB9LCBjbGllbnRBc3NlcnRpb24oYXMsIGNsaWVudCksIGtleSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcyhhcykge1xuICAgIGlmICh0eXBlb2YgYXMgIT09ICdvYmplY3QnIHx8IGFzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXNcIiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFzLmlzc3VlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhcy5pc3N1ZXJcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsaWVudChjbGllbnQpIHtcbiAgICBpZiAodHlwZW9mIGNsaWVudCAhPT0gJ29iamVjdCcgfHwgY2xpZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2xpZW50XCIgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhjbGllbnQuY2xpZW50X2lkKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNsaWVudC5jbGllbnRfaWRcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsaWVudFNlY3JldChjbGllbnRTZWNyZXQpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNsaWVudFNlY3JldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjbGllbnQuY2xpZW50X3NlY3JldFwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGllbnRTZWNyZXQ7XG59XG5mdW5jdGlvbiBhc3NlcnROb0NsaWVudFByaXZhdGVLZXkoY2xpZW50QXV0aE1ldGhvZCwgY2xpZW50UHJpdmF0ZUtleSkge1xuICAgIGlmIChjbGllbnRQcml2YXRlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJvcHRpb25zLmNsaWVudFByaXZhdGVLZXlcIiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBwcm92aWRlZCB3aGVuICR7Y2xpZW50QXV0aE1ldGhvZH0gY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBpcyB1c2VkLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vQ2xpZW50U2VjcmV0KGNsaWVudEF1dGhNZXRob2QsIGNsaWVudFNlY3JldCkge1xuICAgIGlmIChjbGllbnRTZWNyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImNsaWVudC5jbGllbnRfc2VjcmV0XCIgcHJvcGVydHkgbXVzdCBub3QgYmUgcHJvdmlkZWQgd2hlbiAke2NsaWVudEF1dGhNZXRob2R9IGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2QgaXMgdXNlZC5gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjbGllbnRBdXRoZW50aWNhdGlvbihhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzLCBjbGllbnRQcml2YXRlS2V5KSB7XG4gICAgYm9keS5kZWxldGUoJ2NsaWVudF9zZWNyZXQnKTtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X2Fzc2VydGlvbl90eXBlJyk7XG4gICAgYm9keS5kZWxldGUoJ2NsaWVudF9hc3NlcnRpb24nKTtcbiAgICBzd2l0Y2ggKGNsaWVudC50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnY2xpZW50X3NlY3JldF9iYXNpYyc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSgnY2xpZW50X3NlY3JldF9iYXNpYycsIGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBjbGllbnRTZWNyZXRCYXNpYyhjbGllbnQuY2xpZW50X2lkLCBhc3NlcnRDbGllbnRTZWNyZXQoY2xpZW50LmNsaWVudF9zZWNyZXQpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjbGllbnRfc2VjcmV0X3Bvc3QnOiB7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFByaXZhdGVLZXkoJ2NsaWVudF9zZWNyZXRfcG9zdCcsIGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9zZWNyZXQnLCBhc3NlcnRDbGllbnRTZWNyZXQoY2xpZW50LmNsaWVudF9zZWNyZXQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3ByaXZhdGVfa2V5X2p3dCc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50U2VjcmV0KCdwcml2YXRlX2tleV9qd3QnLCBjbGllbnQuY2xpZW50X3NlY3JldCk7XG4gICAgICAgICAgICBpZiAoY2xpZW50UHJpdmF0ZUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmNsaWVudFByaXZhdGVLZXlcIiBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gXCJjbGllbnQudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RcIiBpcyBcInByaXZhdGVfa2V5X2p3dFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGtleSwga2lkIH0gPSBnZXRLZXlBbmRLaWQoY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBpZiAoIWlzUHJpdmF0ZUtleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmNsaWVudFByaXZhdGVLZXkua2V5XCIgbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2Fzc2VydGlvbl90eXBlJywgJ3VybjppZXRmOnBhcmFtczpvYXV0aDpjbGllbnQtYXNzZXJ0aW9uLXR5cGU6and0LWJlYXJlcicpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9hc3NlcnRpb24nLCBhd2FpdCBwcml2YXRlS2V5Snd0KGFzLCBjbGllbnQsIGtleSwga2lkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRTZWNyZXQoJ25vbmUnLCBjbGllbnQuY2xpZW50X3NlY3JldCk7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFByaXZhdGVLZXkoJ25vbmUnLCBjbGllbnRQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgY2xpZW50IHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kJyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gand0KGhlYWRlciwgY2xhaW1zU2V0LCBrZXkpIHtcbiAgICBpZiAoIWtleS51c2FnZXMuaW5jbHVkZXMoJ3NpZ24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDcnlwdG9LZXkgaW5zdGFuY2VzIHVzZWQgZm9yIHNpZ25pbmcgYXNzZXJ0aW9ucyBtdXN0IGluY2x1ZGUgXCJzaWduXCIgaW4gdGhlaXIgXCJ1c2FnZXNcIicpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGAke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpKX0uJHtiNjR1KGJ1ZihKU09OLnN0cmluZ2lmeShjbGFpbXNTZXQpKSl9YDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihrZXlUb1N1YnRsZShrZXkpLCBrZXksIGJ1ZihpbnB1dCkpKTtcbiAgICByZXR1cm4gYCR7aW5wdXR9LiR7c2lnbmF0dXJlfWA7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNzdWVSZXF1ZXN0T2JqZWN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIHByaXZhdGVLZXkpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgY29uc3QgeyBrZXksIGtpZCB9ID0gZ2V0S2V5QW5kS2lkKHByaXZhdGVLZXkpO1xuICAgIGlmICghaXNQcml2YXRlS2V5KGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwcml2YXRlS2V5LmtleVwiIG11c3QgYmUgYSBwcml2YXRlIENyeXB0b0tleScpO1xuICAgIH1cbiAgICBwYXJhbWV0ZXJzLnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICBjb25zdCBjbGFpbXMgPSB7XG4gICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhwYXJhbWV0ZXJzLmVudHJpZXMoKSksXG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgYXVkOiBhcy5pc3N1ZXIsXG4gICAgICAgIGV4cDogbm93ICsgNjAsXG4gICAgICAgIGlhdDogbm93LFxuICAgICAgICBuYmY6IG5vdyxcbiAgICAgICAgaXNzOiBjbGllbnQuY2xpZW50X2lkLFxuICAgIH07XG4gICAgbGV0IHJlc291cmNlO1xuICAgIGlmIChwYXJhbWV0ZXJzLmhhcygncmVzb3VyY2UnKSAmJlxuICAgICAgICAocmVzb3VyY2UgPSBwYXJhbWV0ZXJzLmdldEFsbCgncmVzb3VyY2UnKSkgJiZcbiAgICAgICAgcmVzb3VyY2UubGVuZ3RoID4gMSkge1xuICAgICAgICBjbGFpbXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlcnMuaGFzKCdjbGFpbXMnKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtZXRlcnMuZ2V0KCdjbGFpbXMnKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJjbGFpbXNcIiBwYXJhbWV0ZXIgbXVzdCBiZSBwYXNzZWQgYXMgYSBVVEYtOCBlbmNvZGVkIEpTT04nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xhaW1zLmNsYWltcyA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIHRoZSBcImNsYWltc1wiIHBhcmFtZXRlciBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMuY2xhaW1zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJjbGFpbXNcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gand0KHtcbiAgICAgICAgYWxnOiBrZXlUb0p3cyhrZXkpLFxuICAgICAgICB0eXA6ICdvYXV0aC1hdXRoei1yZXErand0JyxcbiAgICAgICAga2lkLFxuICAgIH0sIGNsYWltcywga2V5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRwb3BQcm9vZkp3dChoZWFkZXJzLCBvcHRpb25zLCB1cmwsIGh0bSwgY2xvY2tTa2V3LCBhY2Nlc3NUb2tlbikge1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5LCBub25jZSA9IGRwb3BOb25jZXMuZ2V0KHVybC5vcmlnaW4pIH0gPSBvcHRpb25zO1xuICAgIGlmICghaXNQcml2YXRlS2V5KHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5wcml2YXRlS2V5XCIgbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5Jyk7XG4gICAgfVxuICAgIGlmICghaXNQdWJsaWNLZXkocHVibGljS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1AucHVibGljS2V5XCIgbXVzdCBiZSBhIHB1YmxpYyBDcnlwdG9LZXknKTtcbiAgICB9XG4gICAgaWYgKG5vbmNlICE9PSB1bmRlZmluZWQgJiYgIXZhbGlkYXRlU3RyaW5nKG5vbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1Aubm9uY2VcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKCFwdWJsaWNLZXkuZXh0cmFjdGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QLnB1YmxpY0tleS5leHRyYWN0YWJsZVwiIG11c3QgYmUgdHJ1ZScpO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGNsb2NrU2tldztcbiAgICBjb25zdCBwcm9vZiA9IGF3YWl0IGp3dCh7XG4gICAgICAgIGFsZzoga2V5VG9Kd3MocHJpdmF0ZUtleSksXG4gICAgICAgIHR5cDogJ2Rwb3Arand0JyxcbiAgICAgICAgandrOiBhd2FpdCBwdWJsaWNKd2socHVibGljS2V5KSxcbiAgICB9LCB7XG4gICAgICAgIGlhdDogbm93LFxuICAgICAgICBqdGk6IHJhbmRvbUJ5dGVzKCksXG4gICAgICAgIGh0bSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGh0dTogYCR7dXJsLm9yaWdpbn0ke3VybC5wYXRobmFtZX1gLFxuICAgICAgICBhdGg6IGFjY2Vzc1Rva2VuID8gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGJ1ZihhY2Nlc3NUb2tlbikpKSA6IHVuZGVmaW5lZCxcbiAgICB9LCBwcml2YXRlS2V5KTtcbiAgICBoZWFkZXJzLnNldCgnZHBvcCcsIHByb29mKTtcbn1cbmxldCBqd2tDYWNoZTtcbmFzeW5jIGZ1bmN0aW9uIHB1YmxpY0p3ayhrZXkpIHtcbiAgICBqd2tDYWNoZSB8fCAoandrQ2FjaGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgICBpZiAoandrQ2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGp3a0NhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IGt0eSwgZSwgbiwgeCwgeSwgY3J2IH0gPSBhd2FpdCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5KTtcbiAgICBjb25zdCBqd2sgPSB7IGt0eSwgZSwgbiwgeCwgeSwgY3J2IH07XG4gICAgandrQ2FjaGUuc2V0KGtleSwgandrKTtcbiAgICByZXR1cm4gandrO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHR5cGVvZiBhcy5wdXNoZWRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLnB1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMucHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdF9lbmRwb2ludCk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IGRwb3BQcm9vZkp3dChoZWFkZXJzLCBvcHRpb25zLkRQb1AsIHVybCwgJ1BPU1QnLCBnZXRDbG9ja1NrZXcoY2xpZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPQXV0aDJFcnJvcihpbnB1dCkge1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuZXJyb3IgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdmFsdWVbMF0gPT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgU1BMSVRfUkVHRVhQID0gLygoPzosfCwgKT9bMC05YS16QS1aISMkJSYnKistLl5fYHx+XSs9KS87XG5jb25zdCBTQ0hFTUVTX1JFR0VYUCA9IC8oPzpefCwgPykoWzAtOWEtekEtWiEjJCUmJyorXFwtLl5fYHx+XSspKD89JHxbICxdKS9nO1xuZnVuY3Rpb24gd3d3QXV0aChzY2hlbWUsIHBhcmFtcykge1xuICAgIGNvbnN0IGFyciA9IHBhcmFtcy5zcGxpdChTUExJVF9SRUdFWFApLnNsaWNlKDEpO1xuICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLCBwYXJhbWV0ZXJzOiB7fSB9O1xuICAgIH1cbiAgICBhcnJbYXJyLmxlbmd0aCAtIDFdID0gYXJyW2Fyci5sZW5ndGggLSAxXS5yZXBsYWNlKC8sJC8sICcnKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaTtcbiAgICAgICAgaWYgKGFycltpZHhdWzBdID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2lkeF0uc2xpY2UoLTEpICE9PSAnXCInICYmICsraSA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhcnJbaWR4XSArPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gYXJyW2lkeCAtIDFdLnJlcGxhY2UoL14oPzosID8pfD0kL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBwYXJhbWV0ZXJzW2tleV0gPSB1bnF1b3RlKGFycltpZHhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBzY2hlbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcGFyYW1ldGVycyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlV3d3QXV0aGVudGljYXRlQ2hhbGxlbmdlcyhyZXNwb25zZSkge1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaGVhZGVycy5oYXMoJ3d3dy1hdXRoZW50aWNhdGUnKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnd3d3LWF1dGhlbnRpY2F0ZScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgeyAxOiBzY2hlbWUsIGluZGV4IH0gb2YgaGVhZGVyLm1hdGNoQWxsKFNDSEVNRVNfUkVHRVhQKSkge1xuICAgICAgICByZXN1bHQucHVzaChbc2NoZW1lLCBpbmRleF0pO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY2hhbGxlbmdlcyA9IHJlc3VsdC5tYXAoKFtzY2hlbWUsIGluZGV4T2ZdLCBpLCBvdGhlcnMpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dCA9IG90aGVyc1tpICsgMV07XG4gICAgICAgIGxldCBwYXJhbWV0ZXJzO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IGhlYWRlci5zbGljZShpbmRleE9mLCBuZXh0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBoZWFkZXIuc2xpY2UoaW5kZXhPZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHd3d0F1dGgoc2NoZW1lLCBwYXJhbWV0ZXJzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbGxlbmdlcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUHVzaGVkQXV0aG9yaXphdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMSkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gUHVzaGVkIEF1dGhvcml6YXRpb24gUmVxdWVzdCBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24ucmVxdWVzdF91cmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwicmVxdWVzdF91cmlcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24uZXhwaXJlc19pbiAhPT0gJ251bWJlcicgfHwganNvbi5leHBpcmVzX2luIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHkgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sIG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBib2R5LCBvcHRpb25zKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhhY2Nlc3NUb2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhY2Nlc3NUb2tlblwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ1cmxcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcpO1xuICAgIH1cbiAgICBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMoaGVhZGVycyk7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF3YWl0IGRwb3BQcm9vZkp3dChoZWFkZXJzLCBvcHRpb25zLkRQb1AsIHVybCwgJ0dFVCcsIGdldENsb2NrU2tldyh7IFtjbG9ja1NrZXddOiBvcHRpb25zPy5jbG9ja1NrZXcgfSksIGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBgRFBvUCAke2FjY2Vzc1Rva2VufWApO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1c2VySW5mb1JlcXVlc3QoYXMsIGNsaWVudCwgYWNjZXNzVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHR5cGVvZiBhcy51c2VyaW5mb19lbmRwb2ludCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhcy51c2VyaW5mb19lbmRwb2ludFwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChhcy51c2VyaW5mb19lbmRwb2ludCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3dCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKCdhY2NlcHQnLCAnYXBwbGljYXRpb24vand0Jyk7XG4gICAgfVxuICAgIHJldHVybiBwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sICdHRVQnLCB1cmwsIGhlYWRlcnMsIG51bGwsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgY2xvY2tTa2V3OiBnZXRDbG9ja1NrZXcoY2xpZW50KSxcbiAgICB9KTtcbn1cbmxldCBqd2tzQ2FjaGU7XG5hc3luYyBmdW5jdGlvbiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKSB7XG4gICAgY29uc3QgeyBhbGcsIGtpZCB9ID0gaGVhZGVyO1xuICAgIGNoZWNrU3VwcG9ydGVkSndzQWxnKGFsZyk7XG4gICAgbGV0IGp3a3M7XG4gICAgbGV0IGFnZTtcbiAgICBqd2tzQ2FjaGUgfHwgKGp3a3NDYWNoZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAgIGlmIChqd2tzQ2FjaGUuaGFzKGFzKSkge1xuICAgICAgICA7XG4gICAgICAgICh7IGp3a3MsIGFnZSB9ID0gandrc0NhY2hlLmdldChhcykpO1xuICAgICAgICBpZiAoYWdlID49IDMwMCkge1xuICAgICAgICAgICAgandrc0NhY2hlLmRlbGV0ZShhcyk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGp3a3MgPSBhd2FpdCBqd2tzUmVxdWVzdChhcywgb3B0aW9ucykudGhlbihwcm9jZXNzSndrc1Jlc3BvbnNlKTtcbiAgICAgICAgYWdlID0gMDtcbiAgICAgICAgandrc0NhY2hlLnNldChhcywge1xuICAgICAgICAgICAgandrcyxcbiAgICAgICAgICAgIGlhdDogZXBvY2hUaW1lKCksXG4gICAgICAgICAgICBnZXQgYWdlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcG9jaFRpbWUoKSAtIHRoaXMuaWF0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBrdHk7XG4gICAgc3dpdGNoIChhbGcuc2xpY2UoMCwgMikpIHtcbiAgICAgICAgY2FzZSAnUlMnOlxuICAgICAgICBjYXNlICdQUyc6XG4gICAgICAgICAgICBrdHkgPSAnUlNBJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFUyc6XG4gICAgICAgICAgICBrdHkgPSAnRUMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VkJzpcbiAgICAgICAgICAgIGt0eSA9ICdPS1AnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBjYW5kaWRhdGVzID0gandrcy5rZXlzLmZpbHRlcigoandrKSA9PiB7XG4gICAgICAgIGlmIChqd2sua3R5ICE9PSBrdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2lkICE9PSB1bmRlZmluZWQgJiYga2lkICE9PSBqd2sua2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp3ay5hbGcgIT09IHVuZGVmaW5lZCAmJiBhbGcgIT09IGp3ay5hbGcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLnVzZSAhPT0gdW5kZWZpbmVkICYmIGp3ay51c2UgIT09ICdzaWcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp3ay5rZXlfb3BzPy5pbmNsdWRlcygndmVyaWZ5JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTMjU2JyAmJiBqd2suY3J2ICE9PSAnUC0yNTYnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzM4NCcgJiYgandrLmNydiAhPT0gJ1AtMzg0JzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVM1MTInICYmIGp3ay5jcnYgIT09ICdQLTUyMSc6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VkRFNBJyAmJiAhKGp3ay5jcnYgPT09ICdFZDI1NTE5JyB8fCBqd2suY3J2ID09PSAnRWQ0NDgnKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgY29uc3QgeyAwOiBqd2ssIGxlbmd0aCB9ID0gY2FuZGlkYXRlcztcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBpZiAoYWdlID49IDYwKSB7XG4gICAgICAgICAgICBqd2tzQ2FjaGUuZGVsZXRlKGFzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdlcnJvciB3aGVuIHNlbGVjdGluZyBhIEpXVCB2ZXJpZmljYXRpb24ga2V5LCBubyBhcHBsaWNhYmxlIGtleXMgZm91bmQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2Vycm9yIHdoZW4gc2VsZWN0aW5nIGEgSldUIHZlcmlmaWNhdGlvbiBrZXksIG11bHRpcGxlIGFwcGxpY2FibGUga2V5cyBmb3VuZCwgYSBcImtpZFwiIEpXVCBIZWFkZXIgUGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGltcG9ydEp3ayhhbGcsIGp3ayk7XG4gICAgaWYgKGtleS50eXBlICE9PSAncHVibGljJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdqd2tzX3VyaSBtdXN0IG9ubHkgY29udGFpbiBwdWJsaWMga2V5cycpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufVxuZXhwb3J0IGNvbnN0IHNraXBTdWJqZWN0Q2hlY2sgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGdldENvbnRlbnRUeXBlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKT8uc3BsaXQoJzsnKVswXTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzVXNlckluZm9SZXNwb25zZShhcywgY2xpZW50LCBleHBlY3RlZFN1YmplY3QsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBVc2VySW5mbyBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBsZXQganNvbjtcbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpID09PSAnYXBwbGljYXRpb24vand0Jykge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgeyBjbGFpbXMgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGF3YWl0IHJlc3BvbnNlLnRleHQoKSwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMudXNlcmluZm9fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIG5vU2lnbmF0dXJlQ2hlY2ssIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlT3B0aW9uYWxJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzLmlzc3VlcikpO1xuICAgICAgICBqc29uID0gY2xhaW1zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgVXNlckluZm8gUmVzcG9uc2UgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnN1YikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJzdWJcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV4cGVjdGVkU3ViamVjdCkge1xuICAgICAgICBjYXNlIHNraXBTdWJqZWN0Q2hlY2s6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWRTdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wiZXhwZWN0ZWRTdWJqZWN0XCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLnN1YiAhPT0gZXhwZWN0ZWRTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInJlc3BvbnNlXCIgYm9keSBcInN1YlwiIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgbWV0aG9kLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCBjbGllbnRBdXRoZW50aWNhdGlvbihhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzLCBvcHRpb25zPy5jbGllbnRQcml2YXRlS2V5KTtcbiAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgcmV0dXJuIGZldGNoKHVybC5ocmVmLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5hc3luYyBmdW5jdGlvbiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCBncmFudFR5cGUsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGFzLnRva2VuX2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLnRva2VuX2VuZHBvaW50XCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFzLnRva2VuX2VuZHBvaW50KTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnZ3JhbnRfdHlwZScsIGdyYW50VHlwZSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnUE9TVCcsIGdldENsb2NrU2tldyhjbGllbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBwYXJhbWV0ZXJzLCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoVG9rZW5HcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgcmVmcmVzaFRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVmcmVzaFRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlZnJlc2hUb2tlblwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgncmVmcmVzaF90b2tlbicsIHJlZnJlc2hUb2tlbik7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdyZWZyZXNoX3Rva2VuJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5jb25zdCBpZFRva2VuQ2xhaW1zID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlZikge1xuICAgIGlmICghcmVmLmlkX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNsYWltcyA9IGlkVG9rZW5DbGFpbXMuZ2V0KHJlZik7XG4gICAgaWYgKCFjbGFpbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZWZcIiB3YXMgYWxyZWFkeSBnYXJiYWdlIGNvbGxlY3RlZCBvciBkaWQgbm90IHJlc29sdmUgZnJvbSB0aGUgcHJvcGVyIHNvdXJjZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYWltcztcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgaWdub3JlSWRUb2tlbiA9IGZhbHNlLCBpZ25vcmVSZWZyZXNoVG9rZW4gPSBmYWxzZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFRva2VuIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5hY2Nlc3NfdG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiYWNjZXNzX3Rva2VuXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnRva2VuX3R5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidG9rZW5fdHlwZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGpzb24udG9rZW5fdHlwZSA9IGpzb24udG9rZW5fdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChqc29uLnRva2VuX3R5cGUgIT09ICdkcG9wJyAmJiBqc29uLnRva2VuX3R5cGUgIT09ICdiZWFyZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBgdG9rZW5fdHlwZWAgdmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXhwaXJlc19pbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICh0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyB8fCBqc29uLmV4cGlyZXNfaW4gPD0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHkgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAoIWlnbm9yZVJlZnJlc2hUb2tlbiAmJlxuICAgICAgICBqc29uLnJlZnJlc2hfdG9rZW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdmFsaWRhdGVTdHJpbmcoanNvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInJlZnJlc2hfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoanNvbi5zY29wZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLnNjb3BlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInNjb3BlXCIgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIWlnbm9yZUlkVG9rZW4pIHtcbiAgICAgICAgaWYgKGpzb24uaWRfdG9rZW4gIT09IHVuZGVmaW5lZCAmJiAhdmFsaWRhdGVTdHJpbmcoanNvbi5pZF90b2tlbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaWRfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLmlkX3Rva2VuKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoanNvbi5pZF90b2tlbiwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIG5vU2lnbmF0dXJlQ2hlY2ssIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2V4cCcsICdpYXQnLCAnaXNzJywgJ3N1YiddKSlcbiAgICAgICAgICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSAmJiBjbGFpbXMuYXVkLmxlbmd0aCAhPT0gMSAmJiBjbGFpbXMuYXpwICE9PSBjbGllbnQuY2xpZW50X2lkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcImF6cFwiIChhdXRob3JpemVkIHBhcnR5KSBjbGFpbSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWVudC5yZXF1aXJlX2F1dGhfdGltZSAmJiB0eXBlb2YgY2xhaW1zLmF1dGhfdGltZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zLnNldChqc29uLCBjbGFpbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5hdWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdC5jbGFpbXMuYXVkKSkge1xuICAgICAgICBpZiAoIXJlc3VsdC5jbGFpbXMuYXVkLmluY2x1ZGVzKGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0LmNsYWltcy5hdWQgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYXVkXCIgKGF1ZGllbmNlKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbElzc3VlcihleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuaXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlSXNzdWVyKGV4cGVjdGVkLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJc3N1ZXIoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmlzcyAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpc3NcIiAoaXNzdWVyKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgYnJhbmRlZCA9IG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiBicmFuZChzZWFyY2hQYXJhbXMpIHtcbiAgICBicmFuZGVkLmFkZChzZWFyY2hQYXJhbXMpO1xuICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aG9yaXphdGlvbkNvZGVHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2FsbGJhY2tQYXJhbWV0ZXJzLCByZWRpcmVjdFVyaSwgY29kZVZlcmlmaWVyLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghYnJhbmRlZC5oYXMoY2FsbGJhY2tQYXJhbWV0ZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrUGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zIG9idGFpbmVkIGZyb20gXCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSgpXCIsIG9yIFwidmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoKScpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHJlZGlyZWN0VXJpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlZGlyZWN0VXJpXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhjb2RlVmVyaWZpZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY29kZVZlcmlmaWVyXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihjYWxsYmFja1BhcmFtZXRlcnMsICdjb2RlJyk7XG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ25vIGF1dGhvcml6YXRpb24gY29kZSBpbiBcImNhbGxiYWNrUGFyYW1ldGVyc1wiJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgncmVkaXJlY3RfdXJpJywgcmVkaXJlY3RVcmkpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdjb2RlX3ZlcmlmaWVyJywgY29kZVZlcmlmaWVyKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnY29kZScsIGNvZGUpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCAnYXV0aG9yaXphdGlvbl9jb2RlJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5jb25zdCBjbGFpbU5hbWVzID0ge1xuICAgIGF1ZDogJ2F1ZGllbmNlJyxcbiAgICBleHA6ICdleHBpcmF0aW9uIHRpbWUnLFxuICAgIGlhdDogJ2lzc3VlZCBhdCcsXG4gICAgaXNzOiAnaXNzdWVyJyxcbiAgICBzdWI6ICdzdWJqZWN0Jyxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVByZXNlbmNlKHJlcXVpcmVkLCByZXN1bHQpIHtcbiAgICBmb3IgKGNvbnN0IGNsYWltIG9mIHJlcXVpcmVkKSB7XG4gICAgICAgIGlmIChyZXN1bHQuY2xhaW1zW2NsYWltXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKGBKV1QgXCIke2NsYWltfVwiICgke2NsYWltTmFtZXNbY2xhaW1dfSkgY2xhaW0gbWlzc2luZ2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgZXhwZWN0Tm9Ob25jZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IHNraXBBdXRoVGltZUNoZWNrID0gU3ltYm9sKCk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT3BlbklEUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIGV4cGVjdGVkTm9uY2UsIG1heEFnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG4gICAgaWYgKGlzT0F1dGgyRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHJlc3VsdC5pZF90b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpZF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIG1heEFnZSA/PyAobWF4QWdlID0gY2xpZW50LmRlZmF1bHRfbWF4X2FnZSA/PyBza2lwQXV0aFRpbWVDaGVjayk7XG4gICAgY29uc3QgY2xhaW1zID0gZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyhyZXN1bHQpO1xuICAgIGlmICgoY2xpZW50LnJlcXVpcmVfYXV0aF90aW1lIHx8IG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spICYmXG4gICAgICAgIGNsYWltcy5hdXRoX3RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdJRCBUb2tlbiBcImF1dGhfdGltZVwiIChhdXRoZW50aWNhdGlvbiB0aW1lKSBjbGFpbSBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmIChtYXhBZ2UgIT09IHNraXBBdXRoVGltZUNoZWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJyB8fCBtYXhBZ2UgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMubWF4X2FnZVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KTtcbiAgICAgICAgaWYgKGNsYWltcy5hdXRoX3RpbWUgKyBtYXhBZ2UgPCBub3cgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3RvbyBtdWNoIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgRW5kLVVzZXIgYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgZXhwZWN0Tm9Ob25jZTpcbiAgICAgICAgICAgIGlmIChjbGFpbXMubm9uY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWROb25jZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4cGVjdGVkTm9uY2VcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGFpbXMubm9uY2UgIT09IGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwibm9uY2VcIiBjbGFpbSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9BdXRoMlJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCB0cnVlKTtcbiAgICBpZiAoaXNPQXV0aDJFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaWRfdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5pZF90b2tlbiA9PT0gJ3N0cmluZycgJiYgcmVzdWx0LmlkX3Rva2VuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnVW5leHBlY3RlZCBJRCBUb2tlbiByZXR1cm5lZCwgdXNlIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlKCkgZm9yIE9wZW5JRCBDb25uZWN0IGNhbGxiYWNrIHByb2Nlc3NpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcmVzdWx0LmlkX3Rva2VuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hlY2tKd3RUeXBlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIHJlc3VsdC5oZWFkZXIudHlwICE9PSAnc3RyaW5nJyB8fCBub3JtYWxpemVUeXAocmVzdWx0LmhlYWRlci50eXApICE9PSBleHBlY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcInR5cFwiIGhlYWRlciBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGllbnRDcmVkZW50aWFsc0dyYW50UmVxdWVzdChhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCAnY2xpZW50X2NyZWRlbnRpYWxzJywgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKSwgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NsaWVudENyZWRlbnRpYWxzUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHRydWUsIHRydWUpO1xuICAgIGlmIChpc09BdXRoMkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXZvY2F0aW9uUmVxdWVzdChhcywgY2xpZW50LCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcy5yZXZvY2F0aW9uX2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLnJldm9jYXRpb25fZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMucmV2b2NhdGlvbl9lbmRwb2ludCk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5kZWxldGUoJ2FjY2VwdCcpO1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Jldm9jYXRpb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gUmV2b2NhdGlvbiBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgYm9keSBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW50cm9zcGVjdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgdG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyh0b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0b2tlblwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXMuaW50cm9zcGVjdGlvbl9lbmRwb2ludCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhcy5pbnRyb3NwZWN0aW9uX2VuZHBvaW50XCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFzLmludHJvc3BlY3Rpb25fZW5kcG9pbnQpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgndG9rZW4nLCB0b2tlbik7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGlmIChvcHRpb25zPy5yZXF1ZXN0Snd0UmVzcG9uc2UgPz8gY2xpZW50LmludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL3Rva2VuLWludHJvc3BlY3Rpb24rand0Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSW50cm9zcGVjdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gSW50cm9zcGVjdGlvbiBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBsZXQganNvbjtcbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpID09PSAnYXBwbGljYXRpb24vdG9rZW4taW50cm9zcGVjdGlvbitqd3QnKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYXdhaXQgcmVzcG9uc2UudGV4dCgpLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmludHJvc3BlY3Rpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIG5vU2lnbmF0dXJlQ2hlY2ssIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAgICAgLnRoZW4oY2hlY2tKd3RUeXBlLmJpbmQodW5kZWZpbmVkLCAndG9rZW4taW50cm9zcGVjdGlvbitqd3QnKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2lhdCcsICdpc3MnXSkpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICAgICAganNvbiA9IGNsYWltcy50b2tlbl9pbnRyb3NwZWN0aW9uO1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIFwidG9rZW5faW50cm9zcGVjdGlvblwiIGNsYWltIG11c3QgYmUgYSBKU09OIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uLmFjdGl2ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiYWN0aXZlXCIgcHJvcGVydHkgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBqd2tzUmVxdWVzdChhcywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBpZiAodHlwZW9mIGFzLmp3a3NfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmp3a3NfdXJpXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFzLmp3a3NfdXJpKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaGVhZGVycy5hcHBlbmQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qd2stc2V0K2pzb24nKTtcbiAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzSndrc1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIEpTT04gV2ViIEtleSBTZXQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ua2V5cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJrZXlzXCIgcHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5ldmVyeS5jYWxsKGpzb24ua2V5cywgaXNKc29uT2JqZWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImtleXNcIiBwcm9wZXJ0eSBtZW1iZXJzIG11c3QgYmUgSldLIGZvcm1hdHRlZCBvYmplY3RzJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID4gMzk5ICYmIHJlc3BvbnNlLnN0YXR1cyA8IDUwMCkge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXNKc29uT2JqZWN0KGpzb24pICYmIHR5cGVvZiBqc29uLmVycm9yID09PSAnc3RyaW5nJyAmJiBqc29uLmVycm9yLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLmVycm9yX2Rlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uZXJyb3JfZGVzY3JpcHRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbi5lcnJvcl91cmkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5lcnJvcl91cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmVycm9yX3VyaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uYWxncyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLmFsZ3MgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmFsZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc29uLnNjb3BlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uc2NvcGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLnNjb3BlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNoZWNrU3VwcG9ydGVkSndzQWxnKGFsZykge1xuICAgIGlmICghU1VQUE9SVEVEX0pXU19BTEdTLmluY2x1ZGVzKGFsZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXUyBcImFsZ1wiIGlkZW50aWZpZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsZztcbn1cbmZ1bmN0aW9uIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGFsZ29yaXRobSkge1xuICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggIT09ICdudW1iZXInIHx8IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoIDwgMjA0OCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKGAke2FsZ29yaXRobS5uYW1lfSBtb2R1bHVzTGVuZ3RoIG11c3QgYmUgYXQgbGVhc3QgMjA0OCBiaXRzYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWNkc2FIYXNoTmFtZShuYW1lZEN1cnZlKSB7XG4gICAgc3dpdGNoIChuYW1lZEN1cnZlKSB7XG4gICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTM4NCc7XG4gICAgICAgIGNhc2UgJ1AtNTIxJzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleVRvU3VidGxlKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ0VDRFNBJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZToga2V5LmFsZ29yaXRobS5uYW1lLFxuICAgICAgICAgICAgICAgIGhhc2g6IGVjZHNhSGFzaE5hbWUoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ1JTQS1QU1MnOiB7XG4gICAgICAgICAgICBjaGVja1JzYUtleUFsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleS5hbGdvcml0aG0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbHRMZW5ndGg6IHBhcnNlSW50KGtleS5hbGdvcml0aG0uaGFzaC5uYW1lLnNsaWNlKC0zKSwgMTApID4+IDMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSU0FTU0EtUEtDUzEtdjFfNSc6XG4gICAgICAgICAgICBjaGVja1JzYUtleUFsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHJldHVybiBrZXkuYWxnb3JpdGhtLm5hbWU7XG4gICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgICAgICByZXR1cm4ga2V5LmFsZ29yaXRobS5uYW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xufVxuY29uc3Qgbm9TaWduYXR1cmVDaGVjayA9IFN5bWJvbCgpO1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVKd3QoandzLCBjaGVja0FsZywgZ2V0S2V5LCBjbG9ja1NrZXcsIGNsb2NrVG9sZXJhbmNlKSB7XG4gICAgY29uc3QgeyAwOiBwcm90ZWN0ZWRIZWFkZXIsIDE6IHBheWxvYWQsIDI6IGVuY29kZWRTaWduYXR1cmUsIGxlbmd0aCB9ID0gandzLnNwbGl0KCcuJyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcignSldFIHN0cnVjdHVyZSBKV1RzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSW52YWxpZCBKV1QnKTtcbiAgICB9XG4gICAgbGV0IGhlYWRlcjtcbiAgICB0cnkge1xuICAgICAgICBoZWFkZXIgPSBKU09OLnBhcnNlKGJ1ZihiNjR1KHByb3RlY3RlZEhlYWRlcikpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBKV1QgSGVhZGVyIGJvZHkgYXMgYmFzZTY0dXJsIGVuY29kZWQgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGhlYWRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIEhlYWRlciBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBjaGVja0FsZyhoZWFkZXIpO1xuICAgIGlmIChoZWFkZXIuY3JpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiY3JpdFwiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYjY0dShlbmNvZGVkU2lnbmF0dXJlKTtcbiAgICBpZiAoZ2V0S2V5ICE9PSBub1NpZ25hdHVyZUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IGdldEtleShoZWFkZXIpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IGAke3Byb3RlY3RlZEhlYWRlcn0uJHtwYXlsb2FkfWA7XG4gICAgICAgIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoa2V5VG9TdWJ0bGUoa2V5KSwga2V5LCBzaWduYXR1cmUsIGJ1ZihpbnB1dCkpO1xuICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1Qgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2xhaW1zO1xuICAgIHRyeSB7XG4gICAgICAgIGNsYWltcyA9IEpTT04ucGFyc2UoYnVmKGI2NHUocGF5bG9hZCkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBKV1QgUGF5bG9hZCBib2R5IGFzIGJhc2U2NHVybCBlbmNvZGVkIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBQYXlsb2FkIG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGlmIChjbGFpbXMuZXhwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuZXhwICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5leHAgPD0gbm93IC0gY2xvY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiZXhwXCIgKGV4cGlyYXRpb24gdGltZSkgY2xhaW0gdmFsdWUsIHRpbWVzdGFtcCBpcyA8PSBub3coKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuaWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuaWF0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpYXRcIiAoaXNzdWVkIGF0KSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5pc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5pc3MgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlzc1wiIChpc3N1ZXIpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLm5iZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLm5iZiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLm5iZiA+IG5vdyArIGNsb2NrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcIm5iZlwiIChub3QgYmVmb3JlKSBjbGFpbSB2YWx1ZSwgdGltZXN0YW1wIGlzID4gbm93KCknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmF1ZCAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoY2xhaW1zLmF1ZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYXVkXCIgKGF1ZGllbmNlKSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaGVhZGVyLCBjbGFpbXMsIHNpZ25hdHVyZSB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkU3RhdGUsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoIShwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInBhcmFtZXRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcywgb3IgVVJMJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdyZXNwb25zZScpO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJwYXJhbWV0ZXJzXCIgZG9lcyBub3QgY29udGFpbiBhIEpBUk0gcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcy5qd2tzX3VyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhcy5qd2tzX3VyaVwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbGFpbXMgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KHJlc3BvbnNlLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5hdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmF1dGhvcml6YXRpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpLmJpbmQodW5kZWZpbmVkLCBhcywgb3B0aW9ucyksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBbJ2F1ZCcsICdleHAnLCAnaXNzJ10pKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjbGFpbXMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGtleSAhPT0gJ2F1ZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlQXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3VsdCwgZXhwZWN0ZWRTdGF0ZSk7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25pbmdBbGdvcml0aG0oY2xpZW50LCBpc3N1ZXIsIGhlYWRlcikge1xuICAgIGlmIChjbGllbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaGVhZGVyLmFsZyAhPT0gY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlzc3VlcikpIHtcbiAgICAgICAgaWYgKCFpc3N1ZXIuaW5jbHVkZXMoaGVhZGVyLmFsZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGhlYWRlci5hbGcgIT09ICdSUzI1NicpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsIG5hbWUpIHtcbiAgICBjb25zdCB7IDA6IHZhbHVlLCBsZW5ndGggfSA9IHBhcmFtZXRlcnMuZ2V0QWxsKG5hbWUpO1xuICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoYFwiJHtuYW1lfVwiIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkIG9ubHkgb25jZWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgY29uc3Qgc2tpcFN0YXRlQ2hlY2sgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBleHBlY3ROb1N0YXRlID0gU3ltYm9sKCk7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgZXhwZWN0ZWRTdGF0ZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGlmICghKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBvciBVUkwnKTtcbiAgICB9XG4gICAgaWYgKGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAncmVzcG9uc2UnKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInBhcmFtZXRlcnNcIiBjb250YWlucyBhIEpBUk0gcmVzcG9uc2UsIHVzZSB2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSgpIGluc3RlYWQgb2YgdmFsaWRhdGVBdXRoUmVzcG9uc2UoKScpO1xuICAgIH1cbiAgICBjb25zdCBpc3MgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2lzcycpO1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdzdGF0ZScpO1xuICAgIGlmICghaXNzICYmIGFzLmF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgncmVzcG9uc2UgcGFyYW1ldGVyIFwiaXNzXCIgKGlzc3VlcikgbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAoaXNzICYmIGlzcyAhPT0gYXMuaXNzdWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgXCJpc3NcIiAoaXNzdWVyKSByZXNwb25zZSBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICB9XG4gICAgc3dpdGNoIChleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlIGV4cGVjdE5vU3RhdGU6XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgXCJzdGF0ZVwiIHJlc3BvbnNlIHBhcmFtZXRlciBlbmNvdW50ZXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc2tpcFN0YXRlQ2hlY2s6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImV4cGVjdGVkU3RhdGVcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdyZXNwb25zZSBwYXJhbWV0ZXIgXCJzdGF0ZVwiIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gZXhwZWN0ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgXCJzdGF0ZVwiIHJlc3BvbnNlIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnZXJyb3InKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JfZGVzY3JpcHRpb246IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnZXJyb3JfZGVzY3JpcHRpb24nKSxcbiAgICAgICAgICAgIGVycm9yX3VyaTogZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcl91cmknKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaWRfdG9rZW4gPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2lkX3Rva2VuJyk7XG4gICAgY29uc3QgdG9rZW4gPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Rva2VuJyk7XG4gICAgaWYgKGlkX3Rva2VuICE9PSB1bmRlZmluZWQgfHwgdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcignaW1wbGljaXQgYW5kIGh5YnJpZCBmbG93cyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYnJhbmQobmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKSk7XG59XG5mdW5jdGlvbiBhbGdUb1N1YnRsZShhbGcsIGNydikge1xuICAgIHN3aXRjaCAoYWxnKSB7XG4gICAgICAgIGNhc2UgJ1BTMjU2JzpcbiAgICAgICAgY2FzZSAnUFMzODQnOlxuICAgICAgICBjYXNlICdQUzUxMic6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnUlNBLVBTUycsIGhhc2g6IGBTSEEtJHthbGcuc2xpY2UoLTMpfWAgfTtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICBjYXNlICdSUzM4NCc6XG4gICAgICAgIGNhc2UgJ1JTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsIGhhc2g6IGBTSEEtJHthbGcuc2xpY2UoLTMpfWAgfTtcbiAgICAgICAgY2FzZSAnRVMyNTYnOlxuICAgICAgICBjYXNlICdFUzM4NCc6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiBgUC0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdFUzUxMic6XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiAnUC01MjEnIH07XG4gICAgICAgIGNhc2UgJ0VkRFNBJzoge1xuICAgICAgICAgICAgc3dpdGNoIChjcnYpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdFZDQ0OCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnY7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbXBvcnRKd2soYWxnLCBqd2spIHtcbiAgICBjb25zdCB7IGV4dCwga2V5X29wcywgdXNlLCAuLi5rZXkgfSA9IGp3aztcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIGtleSwgYWxnVG9TdWJ0bGUoYWxnLCBqd2suY3J2KSwgdHJ1ZSwgWyd2ZXJpZnknXSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV2aWNlQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAodHlwZW9mIGFzLmRldmljZV9hdXRob3JpemF0aW9uX2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmRldmljZV9hdXRob3JpemF0aW9uX2VuZHBvaW50XCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFzLmRldmljZV9hdXRob3JpemF0aW9uX2VuZHBvaW50KTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RldmljZUF1dGhvcml6YXRpb25SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIERldmljZSBBdXRob3JpemF0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5kZXZpY2VfY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJkZXZpY2VfY29kZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi51c2VyX2NvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidXNlcl9jb2RlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnZlcmlmaWNhdGlvbl91cmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidmVyaWZpY2F0aW9uX3VyaVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyB8fCBqc29uLmV4cGlyZXNfaW4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChqc29uLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdmFsaWRhdGVTdHJpbmcoanNvbi52ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInZlcmlmaWNhdGlvbl91cmlfY29tcGxldGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoanNvbi5pbnRlcnZhbCAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2YganNvbi5pbnRlcnZhbCAhPT0gJ251bWJlcicgfHwganNvbi5pbnRlcnZhbCA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImludGVydmFsXCIgcHJvcGVydHkgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXZpY2VDb2RlR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGRldmljZUNvZGUsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhkZXZpY2VDb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRldmljZUNvZGVcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2RldmljZV9jb2RlJywgZGV2aWNlQ29kZSk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpkZXZpY2VfY29kZScsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEZXZpY2VDb2RlUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUtleVBhaXIoYWxnLCBvcHRpb25zKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhhbGcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxnXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgYWxnb3JpdGhtID0gYWxnVG9TdWJ0bGUoYWxnLCBhbGcgPT09ICdFZERTQScgPyBvcHRpb25zPy5jcnYgPz8gJ0VkMjU1MTknIDogdW5kZWZpbmVkKTtcbiAgICBpZiAoYWxnLnN0YXJ0c1dpdGgoJ1BTJykgfHwgYWxnLnN0YXJ0c1dpdGgoJ1JTJykpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhbGdvcml0aG0sIHtcbiAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IG9wdGlvbnM/Lm1vZHVsdXNMZW5ndGggPz8gMjA0OCxcbiAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBuZXcgVWludDhBcnJheShbMHgwMSwgMHgwMCwgMHgwMV0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KGFsZ29yaXRobSwgb3B0aW9ucz8uZXh0cmFjdGFibGUgPz8gZmFsc2UsIFsnc2lnbicsICd2ZXJpZnknXSkpO1xufVxuIl0sIm5hbWVzIjpbIlVTRVJfQUdFTlQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzdGFydHNXaXRoIiwiTkFNRSIsIlZFUlNJT04iLCJjbG9ja1NrZXciLCJTeW1ib2wiLCJjbG9ja1RvbGVyYW5jZSIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZiIsImlucHV0IiwiZW5jb2RlIiwiZGVjb2RlIiwiQ0hVTktfU0laRSIsImVuY29kZUJhc2U2NFVybCIsIkFycmF5QnVmZmVyIiwiVWludDhBcnJheSIsImFyciIsImkiLCJieXRlTGVuZ3RoIiwicHVzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5Iiwic3ViYXJyYXkiLCJidG9hIiwiam9pbiIsInJlcGxhY2UiLCJkZWNvZGVCYXNlNjRVcmwiLCJiaW5hcnkiLCJhdG9iIiwiYnl0ZXMiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY2F1c2UiLCJPUEUiLCJiNjR1IiwiTFJVIiwiY29uc3RydWN0b3IiLCJtYXhTaXplIiwiY2FjaGUiLCJNYXAiLCJfY2FjaGUiLCJnZXQiLCJrZXkiLCJ2IiwidXBkYXRlIiwidW5kZWZpbmVkIiwiaGFzIiwic2V0IiwidmFsdWUiLCJkZWxldGUiLCJzaXplIiwiVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciIsIkVycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIk9wZXJhdGlvblByb2Nlc3NpbmdFcnJvciIsIm9wdGlvbnMiLCJkcG9wTm9uY2VzIiwiaXNDcnlwdG9LZXkiLCJDcnlwdG9LZXkiLCJpc1ByaXZhdGVLZXkiLCJ0eXBlIiwiaXNQdWJsaWNLZXkiLCJTVVBQT1JURURfSldTX0FMR1MiLCJwcm9jZXNzRHBvcE5vbmNlIiwicmVzcG9uc2UiLCJ1cmwiLCJVUkwiLCJoZWFkZXJzIiwib3JpZ2luIiwibm9ybWFsaXplVHlwIiwidG9Mb3dlckNhc2UiLCJpc0pzb25PYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJwcmVwYXJlSGVhZGVycyIsIkhlYWRlcnMiLCJUeXBlRXJyb3IiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsImRpc2NvdmVyeVJlcXVlc3QiLCJpc3N1ZXJJZGVudGlmaWVyIiwicHJvdG9jb2wiLCJocmVmIiwiYWxnb3JpdGhtIiwicGF0aG5hbWUiLCJmZXRjaCIsIm1ldGhvZCIsInJlZGlyZWN0IiwidGhlbiIsInZhbGlkYXRlU3RyaW5nIiwicHJvY2Vzc0Rpc2NvdmVyeVJlc3BvbnNlIiwiZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyIiwiUmVzcG9uc2UiLCJzdGF0dXMiLCJhc3NlcnRSZWFkYWJsZVJlc3BvbnNlIiwianNvbiIsImlzc3VlciIsInJhbmRvbUJ5dGVzIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiZ2VuZXJhdGVSYW5kb21Db2RlVmVyaWZpZXIiLCJnZW5lcmF0ZVJhbmRvbVN0YXRlIiwiZ2VuZXJhdGVSYW5kb21Ob25jZSIsImNhbGN1bGF0ZVBLQ0VDb2RlQ2hhbGxlbmdlIiwiY29kZVZlcmlmaWVyIiwic3VidGxlIiwiZGlnZXN0IiwiZ2V0S2V5QW5kS2lkIiwia2lkIiwiZm9ybVVybEVuY29kZSIsInRva2VuIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY2xpZW50U2VjcmV0QmFzaWMiLCJjbGllbnRJZCIsImNsaWVudFNlY3JldCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJjcmVkZW50aWFscyIsInBzQWxnIiwiaGFzaCIsInJzQWxnIiwiZXNBbGciLCJuYW1lZEN1cnZlIiwia2V5VG9Kd3MiLCJnZXRDbG9ja1NrZXciLCJjbGllbnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImdldENsb2NrVG9sZXJhbmNlIiwidG9sZXJhbmNlIiwiTWF0aCIsInNpZ24iLCJlcG9jaFRpbWUiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJjbGllbnRBc3NlcnRpb24iLCJhcyIsImp0aSIsImF1ZCIsInRva2VuX2VuZHBvaW50IiwiZXhwIiwiaWF0IiwibmJmIiwiaXNzIiwiY2xpZW50X2lkIiwic3ViIiwicHJpdmF0ZUtleUp3dCIsImp3dCIsImFsZyIsImFzc2VydEFzIiwiYXNzZXJ0Q2xpZW50IiwiYXNzZXJ0Q2xpZW50U2VjcmV0IiwiYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5IiwiY2xpZW50QXV0aE1ldGhvZCIsImNsaWVudFByaXZhdGVLZXkiLCJhc3NlcnROb0NsaWVudFNlY3JldCIsImNsaWVudEF1dGhlbnRpY2F0aW9uIiwiYm9keSIsInRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kIiwiY2xpZW50X3NlY3JldCIsImhlYWRlciIsImNsYWltc1NldCIsInVzYWdlcyIsImluY2x1ZGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInNpZ25hdHVyZSIsImtleVRvU3VidGxlIiwiaXNzdWVSZXF1ZXN0T2JqZWN0IiwicGFyYW1ldGVycyIsInByaXZhdGVLZXkiLCJVUkxTZWFyY2hQYXJhbXMiLCJjbGFpbXMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJyZXNvdXJjZSIsImdldEFsbCIsInBhcnNlIiwidHlwIiwiZHBvcFByb29mSnd0IiwiaHRtIiwiYWNjZXNzVG9rZW4iLCJwdWJsaWNLZXkiLCJub25jZSIsImV4dHJhY3RhYmxlIiwicHJvb2YiLCJqd2siLCJwdWJsaWNKd2siLCJodHUiLCJhdGgiLCJqd2tDYWNoZSIsIldlYWtNYXAiLCJrdHkiLCJlIiwibiIsIngiLCJ5IiwiY3J2IiwiZXhwb3J0S2V5IiwicHVzaGVkQXV0aG9yaXphdGlvblJlcXVlc3QiLCJwdXNoZWRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2VuZHBvaW50IiwiRFBvUCIsImF1dGhlbnRpY2F0ZWRSZXF1ZXN0IiwiaXNPQXV0aDJFcnJvciIsImVycm9yIiwidW5xdW90ZSIsInNsaWNlIiwiU1BMSVRfUkVHRVhQIiwiU0NIRU1FU19SRUdFWFAiLCJ3d3dBdXRoIiwic2NoZW1lIiwicGFyYW1zIiwic3BsaXQiLCJpZHgiLCJwYXJzZVd3d0F1dGhlbnRpY2F0ZUNoYWxsZW5nZXMiLCJyZXN1bHQiLCJpbmRleCIsIm1hdGNoQWxsIiwiY2hhbGxlbmdlcyIsIm1hcCIsImluZGV4T2YiLCJvdGhlcnMiLCJuZXh0IiwicHJvY2Vzc1B1c2hlZEF1dGhvcml6YXRpb25SZXNwb25zZSIsImVyciIsImhhbmRsZU9BdXRoQm9keUVycm9yIiwicmVxdWVzdF91cmkiLCJleHBpcmVzX2luIiwicHJvdGVjdGVkUmVzb3VyY2VSZXF1ZXN0IiwidXNlckluZm9SZXF1ZXN0IiwidXNlcmluZm9fZW5kcG9pbnQiLCJ1c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnIiwiYXBwZW5kIiwiandrc0NhY2hlIiwiZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkiLCJjaGVja1N1cHBvcnRlZEp3c0FsZyIsImp3a3MiLCJhZ2UiLCJqd2tzUmVxdWVzdCIsInByb2Nlc3NKd2tzUmVzcG9uc2UiLCJjYW5kaWRhdGVzIiwia2V5cyIsImZpbHRlciIsInVzZSIsImtleV9vcHMiLCJpbXBvcnRKd2siLCJza2lwU3ViamVjdENoZWNrIiwiZ2V0Q29udGVudFR5cGUiLCJwcm9jZXNzVXNlckluZm9SZXNwb25zZSIsImV4cGVjdGVkU3ViamVjdCIsInZhbGlkYXRlSnd0IiwidGV4dCIsImNoZWNrU2lnbmluZ0FsZ29yaXRobSIsImJpbmQiLCJ1c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwibm9TaWduYXR1cmVDaGVjayIsInZhbGlkYXRlT3B0aW9uYWxBdWRpZW5jZSIsInZhbGlkYXRlT3B0aW9uYWxJc3N1ZXIiLCJ0b2tlbkVuZHBvaW50UmVxdWVzdCIsImdyYW50VHlwZSIsInJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdCIsInJlZnJlc2hUb2tlbiIsImFkZGl0aW9uYWxQYXJhbWV0ZXJzIiwiaWRUb2tlbkNsYWltcyIsImdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMiLCJyZWYiLCJpZF90b2tlbiIsInByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZSIsImlnbm9yZUlkVG9rZW4iLCJpZ25vcmVSZWZyZXNoVG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJ0b2tlbl90eXBlIiwicmVmcmVzaF90b2tlbiIsInNjb3BlIiwiaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZVByZXNlbmNlIiwidmFsaWRhdGVJc3N1ZXIiLCJ2YWxpZGF0ZUF1ZGllbmNlIiwiYXpwIiwicmVxdWlyZV9hdXRoX3RpbWUiLCJhdXRoX3RpbWUiLCJwcm9jZXNzUmVmcmVzaFRva2VuUmVzcG9uc2UiLCJleHBlY3RlZCIsImJyYW5kZWQiLCJXZWFrU2V0IiwiYnJhbmQiLCJzZWFyY2hQYXJhbXMiLCJhZGQiLCJhdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdCIsImNhbGxiYWNrUGFyYW1ldGVycyIsInJlZGlyZWN0VXJpIiwiY29kZSIsImdldFVSTFNlYXJjaFBhcmFtZXRlciIsImNsYWltTmFtZXMiLCJyZXF1aXJlZCIsImNsYWltIiwiZXhwZWN0Tm9Ob25jZSIsInNraXBBdXRoVGltZUNoZWNrIiwicHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT3BlbklEUmVzcG9uc2UiLCJleHBlY3RlZE5vbmNlIiwibWF4QWdlIiwiZGVmYXVsdF9tYXhfYWdlIiwicHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UiLCJjaGVja0p3dFR5cGUiLCJjbGllbnRDcmVkZW50aWFsc0dyYW50UmVxdWVzdCIsInByb2Nlc3NDbGllbnRDcmVkZW50aWFsc1Jlc3BvbnNlIiwicmV2b2NhdGlvblJlcXVlc3QiLCJyZXZvY2F0aW9uX2VuZHBvaW50IiwicHJvY2Vzc1Jldm9jYXRpb25SZXNwb25zZSIsImJvZHlVc2VkIiwiaW50cm9zcGVjdGlvblJlcXVlc3QiLCJpbnRyb3NwZWN0aW9uX2VuZHBvaW50IiwicmVxdWVzdEp3dFJlc3BvbnNlIiwiaW50cm9zcGVjdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwicHJvY2Vzc0ludHJvc3BlY3Rpb25SZXNwb25zZSIsImludHJvc3BlY3Rpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsInRva2VuX2ludHJvc3BlY3Rpb24iLCJhY3RpdmUiLCJqd2tzX3VyaSIsInByb3RvdHlwZSIsImV2ZXJ5IiwiY2FsbCIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3JfdXJpIiwiYWxncyIsImNoZWNrUnNhS2V5QWxnb3JpdGhtIiwibW9kdWx1c0xlbmd0aCIsImVjZHNhSGFzaE5hbWUiLCJzYWx0TGVuZ3RoIiwicGFyc2VJbnQiLCJqd3MiLCJjaGVja0FsZyIsImdldEtleSIsInByb3RlY3RlZEhlYWRlciIsInBheWxvYWQiLCJlbmNvZGVkU2lnbmF0dXJlIiwiY3JpdCIsInZlcmlmaWVkIiwidmVyaWZ5IiwidmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UiLCJleHBlY3RlZFN0YXRlIiwiYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiYXV0aG9yaXphdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidmFsaWRhdGVBdXRoUmVzcG9uc2UiLCJza2lwU3RhdGVDaGVjayIsImV4cGVjdE5vU3RhdGUiLCJzdGF0ZSIsImF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJhbGdUb1N1YnRsZSIsImV4dCIsImltcG9ydEtleSIsImRldmljZUF1dGhvcml6YXRpb25SZXF1ZXN0IiwiZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQiLCJwcm9jZXNzRGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlIiwiZGV2aWNlX2NvZGUiLCJ1c2VyX2NvZGUiLCJ2ZXJpZmljYXRpb25fdXJpIiwidmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSIsImludGVydmFsIiwiZGV2aWNlQ29kZUdyYW50UmVxdWVzdCIsImRldmljZUNvZGUiLCJwcm9jZXNzRGV2aWNlQ29kZVJlc3BvbnNlIiwiZ2VuZXJhdGVLZXlQYWlyIiwiYXNzaWduIiwicHVibGljRXhwb25lbnQiLCJnZW5lcmF0ZUtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/oauth4webapi/build/index.js\n");

/***/ })

};
;